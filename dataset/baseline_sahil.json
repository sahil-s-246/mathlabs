[

  {"problem_id": "62-001",
  "question_type": "short_answer",
  "source": {
    "type": "extract",
    "book_title": "Probability and Statistics for Data Science",
    "authors": [
      "Carlos Fernandez-Granda"
    ],
    "edition": null,
    "chapter": 11,
    "page": "11",
    "exercise_number": "551"
  },
  "subfield": [
    "statistics"
  ],
  "topic": [
    "probability",
    "variance",
    "covariance",
    "decision_theory"
  ],
  "gradelevel": [
    "College-level"
  ],
  "statement": "11.2 (Basketball team) The coach of a basketball team needs to select two out of three players to complete the line-up for the last quarter of a game. The covariance matrix of the points scored by the players per quarter is the following:\n\n<table id=\"0-1\">\n<tr><td></td><td>Player A</td><td>Player B</td><td>Player C</td></tr>\n<tr><td>Player A</td><td>100</td><td>-80</td><td>10</td></tr>\n<tr><td>Player B</td><td>-80</td><td>81</td><td>50</td></tr>\n<tr><td>Player C</td><td>10</td><td>50</td><td>100</td></tr>\n</table>\n\nCompute the variance of the total number of points, if the coach plays the three possible combinations of two players. Assuming all three players score the same number of points on average, which combination would you recommend to the coach, if they are winning by a wide margin? Which would you recommend, if they are losing by a wide margin?",
  "diagram_data": {
    "type": "table",
    "description": "A covariance matrix for the points scored by three basketball players (A, B, C).",
    "image_path": "images/62-001.png"
  },
  "hints": [
    "Recall the formula for the variance of the sum of two random variables, X and Y: $Var(X + Y) = Var(X) + Var(Y) + 2 Cov(X, Y)$.",
    "The diagonal entries of the covariance matrix represent the variance of each player's score. For example, $Var(A) = 100$. The off-diagonal entries represent the covariance between two players.",
    "Think about what variance represents in a real-world scenario. Low variance implies a more predictable and consistent outcome, while high variance implies a less predictable outcome with higher potential for both very good and very bad results.",
    "If the team is winning by a wide margin, the coach likely wants to minimize risk and secure the win. If the team is losing by a wide margin, the coach might need to take a risk on a high-potential but less predictable outcome."
  ],
  "solution": "**1. Compute the variance for each combination:**\nLet A, B, and C be the random variables representing the points scored by each player. The variance of the sum of points for any two players is given by the formula $Var(X + Y) = Var(X) + Var(Y) + 2 Cov(X, Y)$.\n\n* **Combination (A, B):**\n    $Var(A + B) = Var(A) + Var(B) + 2 Cov(A, B)$\n    $Var(A + B) = 100 + 81 + 2(-80) = 181 - 160 = 21$\n\n* **Combination (A, C):**\n    $Var(A + C) = Var(A) + Var(C) + 2 Cov(A, C)$\n    $Var(A + C) = 100 + 100 + 2(10) = 200 + 20 = 220$\n\n* **Combination (B, C):**\n    $Var(B + C) = Var(B) + Var(C) + 2 Cov(B, C)$\n    $Var(B + C) = 81 + 100 + 2(50) = 181 + 100 = 281$\n\n**Summary of Variances:**\n* Pair (A, B): Variance = 21\n* Pair (A, C): Variance = 220\n* Pair (B, C): Variance = 281\n\n**2. Recommendations:**\nSince all players score the same on average, the decision should be based on the variance, which measures the risk or unpredictability of the outcome.\n\n* **Winning by a wide margin:** The coach should choose the most predictable, lowest-risk option to maintain the lead. This corresponds to the pair with the **lowest variance**.\n    * **Recommendation: Players A and B** (Variance = 21). The strong negative covariance means that if one player has an off-quarter, the other tends to compensate, leading to a very consistent total score.\n\n* **Losing by a wide margin:** The coach needs a high-risk, high-reward strategy to have a chance at a comeback. This corresponds to the pair with the **highest variance**, as this combination has the greatest potential for an exceptionally high-scoring quarter (though also the greatest risk of a very low-scoring one).\n    * **Recommendation: Players B and C** (Variance = 281). The large positive covariance means their performances are positively correlated, making a \"boom or bust\" outcome more likely.",
  "validation_status": "verified",
  "flags": []
},
    {
        "problem_id": "94-001",
        "source": {
            "type": "extract",
            "name": "Digital Logic Design Course Exercises"
        },
        "subfield": [
            "Computer Science"
        ],
        "topic": [
            "Logic Gates",
            "Boolean Algebra",
            "Digital Circuits"
        ],
        "gradelevel": [],
        "statement": "In Exercises 1\u20134 find the output of the given circuit.\n\n1. Logic circuit with inputs x and y going into an OR gate. Input y also goes into a NOT gate. The outputs of the OR gate and the NOT gate then go into an AND gate, which produces the final output.",
        "diagram_data": {
            "type": "latex_tikz",
            "code": "\\begin{tikzpicture}[circuit logic US,\n    font=\\small,\n    % Gate styles\n    or gate/.append style={draw, fill=white},\n    not gate/.append style={draw, fill=white},\n    and gate/.append style={draw, fill=white},\n    % Wire style\n    line width=0.8pt,\n    % Input/Output connections style\n    logic external connectors, % This enables .input and .output anchors\n    every node/.style={minimum size=0.5cm} % Adjust size for better fit\n]\n    % Gates\n    \\node[or gate] (OR1) at (2, 0.5) {};\n    \\node[not gate] (NOT1) at (2, -1.5) {};\n    \\node[and gate] (AND1) at (4, -0.5) {};\n\n    % Inputs\n    \\coordinate (x_start) at (0, 1.5);\n    \\coordinate (y_start) at (0, -0.5);\n\n    \\node[left=0.1cm of x_start] {x};\n    \\node[left=0.1cm of y_start] {y};\n\n    % Connect x to OR gate\n    \\draw (x_start) -- (OR1.input 1);\n\n    % Connect y to OR gate and NOT gate\n    % Use a branch point for the 'y' input\n    \\draw (y_start) -- ([xshift=0.5cm]y_start) node[coordinate, midway] (y_branch) {} -- (OR1.input 2);\n    \\draw (y_branch) |- (NOT1.input);\n\n    % Connect OR gate output to AND gate\n    \\draw (OR1.output) -- (AND1.input 1);\n\n    % Connect NOT gate output to AND gate\n    \\draw (NOT1.output) -- (AND1.input 2);\n\n    % Final Output\n    \\draw (AND1.output) -- node[above] {Output} ++(1.5, 0);\n\\end{tikzpicture}"
        },
        "hints": [
            "Start by identifying each logic gate in the circuit. Write down the Boolean expression for the output of each of the first-level gates (the OR and NOT gates) in terms of the inputs `x` and `y`.",
            "Trace the outputs from the first-level gates. These outputs become the inputs for the final AND gate.",
            "Combine the expressions you found in the first step. Use the AND operator to connect the output of the OR gate with the output of the NOT gate to get the final expression."
        ],
        "solution": "To find the output of the given logic circuit, we will analyze it step-by-step, determining the output of each gate in the order of signal flow.\n\n**Step 1: Analyze the first-level gates**\n\nThe circuit has two gates that take the initial inputs `x` and `y`:\n1.  **OR Gate:** This gate takes both `x` and `y` as inputs. The Boolean expression for an OR operation is represented by the symbol `\u2228`. Let's call the output of this gate `A`.\n    *   `A = x \u2228 y` (which means `x` OR `y`)\n\n2.  **NOT Gate:** This gate takes only `y` as an input. The Boolean expression for a NOT operation is the negation of its input, represented by the symbol `\u00ac`. Let's call the output of this gate `B`.\n    *   `B = \u00acy` (which means `NOT y`, often written as `y'`)\n\n**Step 2: Analyze the final gate**\n\nThe outputs from the first-level gates, `A` and `B`, are then fed into a final AND gate. This AND gate produces the final output of the entire circuit. Let's call the final output `F`. The Boolean expression for an AND operation is represented by the symbol `\u2227`.\n*   `F = A \u2227 B` (which means `A` AND `B`)\n\n**Step 3: Combine the expressions to find the final output**\n\nNow, we substitute the expressions for `A` and `B` from Step 1 into the expression for `F` from Step 2.\n*   Substitute `A = x \u2228 y` and `B = \u00acy`.\n*   `F = (x \u2228 y) \u2227 (\u00acy)`\n\nThis is the final output expression for the circuit.\n\n**Step 4 (Optional): Simplification and Truth Table Verification**\n\nWe can simplify this expression using the laws of Boolean algebra.\nUsing the distributive law, which states `(P \u2228 Q) \u2227 R = (P \u2227 R) \u2228 (Q \u2227 R)`:\n*   `F = (x \u2227 \u00acy) \u2228 (y \u2227 \u00acy)`\n\nWe know that `y \u2227 \u00acy` (`y` AND `NOT y`) is always false (0), because a variable and its negation can never both be true at the same time. This is the law of non-contradiction.\n*   `F = (x \u2227 \u00acy) \u2228 0`\n\nAccording to the identity law, anything OR'd with 0 is just itself (`P \u2228 0 = P`).\n*   `F = x \u2227 \u00acy`\n\nSo, the simplified output of the circuit is `x \u2227 \u00acy`.\n\nTo verify this, let's create a truth table for the original expression `(x \u2228 y) \u2227 (\u00acy)`:\n\n| x | y | x \u2228 y | \u00acy | (x \u2228 y) \u2227 (\u00acy) |\n|:-:|:-:|:-----:|:--:|:----------------:| \n| 0 | 0 |   0   |  1 |     0 \u2227 1 = **0**    |\n| 0 | 1 |   1   |  0 |     1 \u2227 0 = **0**    |\n| 1 | 0 |   1   |  1 |     1 \u2227 1 = **1**    |\n| 1 | 1 |   1   |  0 |     1 \u2227 0 = **0**    |\n\nThe output is 1 only when `x = 1` and `y = 0`, which is exactly the behavior of the simplified expression `x \u2227 \u00acy`.\n\nTherefore, the output of the given circuit is **(x \u2228 y) \u2227 (\u00acy)**, which simplifies to **x \u2227 \u00acy**.",
        "validation_status": "unverified",
        "flags": [],
        "question_type": "short_answer"
    },
    {
        "problem_id": "94-002",
        "source": {
            "type": "extract",
            "name": "Digital Logic Design"
        },
        "subfield": [
            "Computer Science"
        ],
        "topic": [
            "Threshold Logic",
            "Boolean Algebra",
            "Digital Logic Gates"
        ],
        "gradelevel": [],
        "statement": "A threshold gate produces an output y of 1 if and only if $w_1x_1 + w_2x_2 + \\dots + w_nx_n \\ge T$. Find a Boolean expression for the Boolean function represented by the threshold gate with inputs $x_1, x_2, x_3$, weights $w_1 = -1, w_2 = 1, w_3 = 2$, and threshold $T = 1/2$.",
        "diagram_data": {
            "type": "none",
            "code": ""
        },
        "hints": [
            "Since the inputs x\u2081, x\u2082, and x\u2083 are Boolean, they can only be 0 or 1. Start by creating a truth table that lists all 8 possible combinations of these inputs.",
            "For each input combination in your truth table, calculate the weighted sum S = (-1)x\u2081 + (1)x\u2082 + (2)x\u2083. Then, determine the output 'y' by checking if S is greater than or equal to the threshold T = 1/2.",
            "Once you have a complete truth table, write down the sum-of-products (disjunctive normal form) expression by OR-ing the minterms for every row where the output is 1. Then, simplify this expression using Boolean algebra or a Karnaugh map."
        ],
        "solution": "The problem asks for a Boolean expression that represents a specific threshold gate. A threshold gate's output, y, is 1 if the weighted sum of its inputs is greater than or equal to a threshold, T. Otherwise, the output is 0.\n\n**Given Parameters:**\n- Inputs: x\u2081, x\u2082, x\u2083\n- Weights: w\u2081 = -1, w\u2082 = 1, w\u2083 = 2\n- Threshold: T = 1/2\n\nThe condition for the output y to be 1 is:\n$w_1x_1 + w_2x_2 + w_3x_3 \\ge T$\n$(-1)x_1 + (1)x_2 + (2)x_3 \\ge 1/2$\n\nTo find the Boolean expression, we can systematically evaluate this condition for all possible combinations of the Boolean inputs x\u2081, x\u2082, and x\u2083.\n\n**Step 1: Create a Truth Table**\nWe will construct a truth table with all 8 possible input combinations (2\u00b3 = 8). For each combination, we'll calculate the weighted sum (let's call it S) and then determine the output y based on whether S \u2265 1/2.\n\n| x\u2081 | x\u2082 | x\u2083 | Weighted Sum (S = -x\u2081 + x\u2082 + 2x\u2083) | Condition (S \u2265 1/2?) | Output (y) |\n|----|----|----|---------------------------------------|--------------------------|------------|\n| 0  | 0  | 0  | -0 + 0 + 2(0) = 0                     | No                       | 0          |\n| 0  | 0  | 1  | -0 + 0 + 2(1) = 2                     | Yes                      | 1          |\n| 0  | 1  | 0  | -0 + 1 + 2(0) = 1                     | Yes                      | 1          |\n| 0  | 1  | 1  | -0 + 1 + 2(1) = 3                     | Yes                      | 1          |\n| 1  | 0  | 0  | -1 + 0 + 2(0) = -1                    | No                       | 0          |\n| 1  | 0  | 1  | -1 + 0 + 2(1) = 1                     | Yes                      | 1          |\n| 1  | 1  | 0  | -1 + 1 + 2(0) = 0                     | No                       | 0          |\n| 1  | 1  | 1  | -1 + 1 + 2(1) = 2                     | Yes                      | 1          |\n\n**Step 2: Derive the Boolean Expression from the Truth Table**\nNow, we identify the input combinations for which the output y is 1. We can write a sum-of-products (disjunctive normal form) expression by creating a minterm for each of these rows and OR-ing them together. A minterm is an AND product of the input variables, where the variable is complemented if its value is 0.\n\nThe rows where y = 1 are:\n- (x\u2081, x\u2082, x\u2083) = (0, 0, 1) \u2192 Minterm: x\u2081'x\u2082'x\u2083\n- (x\u2081, x\u2082, x\u2083) = (0, 1, 0) \u2192 Minterm: x\u2081'x\u2082x\u2083'\n- (x\u2081, x\u2082, x\u2083) = (0, 1, 1) \u2192 Minterm: x\u2081'x\u2082x\u2083\n- (x\u2081, x\u2082, x\u2083) = (1, 0, 1) \u2192 Minterm: x\u2081x\u2082'x\u2083\n- (x\u2081, x\u2082, x\u2083) = (1, 1, 1) \u2192 Minterm: x\u2081x\u2082x\u2083\n\nThe unsimplified Boolean expression is:\ny = x\u2081'x\u2082'x\u2083 + x\u2081'x\u2082x\u2083' + x\u2081'x\u2082x\u2083 + x\u2081x\u2082'x\u2083 + x\u2081x\u2082x\u2083\n\n**Step 3: Simplify the Boolean Expression**\nWe can simplify this expression using Boolean algebra or a Karnaugh map (K-map). Using a K-map is often more straightforward.\n\nHere is the 3-variable K-map for our function y:\n\n      x\u2082x\u2083\nx\u2081   00  01  11  10\n   \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n0  \u2502 0 \u2502 1 \u2502 1 \u2502 1 \u2502\n   \u251c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n1  \u2502 0 \u2502 1 \u2502 1 \u2502 0 \u2502\n   \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n\nWe group the 1s to find the simplest terms:\n1.  **Group 1 (Green):** A 2x2 group covering the cells where x\u2083=1. In this group, x\u2081 and x\u2082 both change, but x\u2083 remains 1. This group simplifies to the term **x\u2083**.\n    (This covers minterms x\u2081'x\u2082'x\u2083, x\u2081'x\u2082x\u2083, x\u2081x\u2082'x\u2083, and x\u2081x\u2082x\u2083.)\n\n          x\u2082x\u2083\n    x\u2081   00  01  11  10\n       \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n    0  \u2502 0 \u2502 1 \u2502 1 \u2502 1 \u2502\n       \u251c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n    1  \u2502 0 \u2502 1 \u2502 1 \u2502 0 \u2502\n       \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n           \\___/ \\___/\n             x\u2083\n\n2.  **Group 2 (Blue):** A horizontal group of two covering the cells where x\u2081=0 and x\u2082=1. In this group, x\u2081 is 0 (x\u2081') and x\u2082 is 1 (x\u2082), while x\u2083 changes. This group simplifies to the term **x\u2081'x\u2082**.\n    (This covers minterms x\u2081'x\u2082x\u2083' and x\u2081'x\u2082x\u2083.)\n\n          x\u2082x\u2083\n    x\u2081   00  01  11  10\n       \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n    0  \u2502 0 \u2502 1 \u2502 1 \u2502 1 \u2502\n       \u251c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2524\u2500\u2500\u2500\u2524   <- x\u2081'x\u2082\n    1  \u2502 0 \u2502 1 \u2502 1 \u2502 0 \u2502\n       \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n\nCombining the terms from our groups gives the final simplified Boolean expression:\ny = x\u2083 + x\u2081'x\u2082\n\n**Final Answer:**\nThe Boolean expression for the given threshold gate is **y = x\u2081'x\u2082 + x\u2083** (or equivalently, **y = x\u2083 OR (NOT x\u2081 AND x\u2082)**).",
        "validation_status": "unverified",
        "flags": [],
        "question_type": "short_answer"
    },
    {
        "problem_id": "68-001",
        "source": {
            "type": "extract",
            "name": "Theory of Computation"
        },
        "subfield": [
            "Computer Science"
        ],
        "topic": [
            "Moore Machines",
            "Finite State Automata",
            "State Diagrams",
            "State Tables"
        ],
        "gradelevel": [],
        "statement": "20. Construct the state diagram for the Moore machine with this state table.\n\n<table id=\"0-1\">\n<tr><td id=\"0-2\"></td><td id=\"0-3\" colspan=\"2\">f</td><td id=\"0-4\"></td></tr>\n<tr><td id=\"0-5\">State</td><td id=\"0-6\" colspan=\"2\">Input 0 1</td><td id=\"0-7\">g</td></tr>\n<tr><td id=\"0-8\">s\u2080</td><td id=\"0-9\">s\u2080</td><td id=\"0-a\">s\u2082</td><td id=\"0-b\">0</td></tr>\n<tr><td id=\"0-c\">s\u2081</td><td id=\"0-d\">s\u2083</td><td id=\"0-e\">s\u2080</td><td id=\"0-f\">1</td></tr>\n<tr><td id=\"0-g\">s\u2082</td><td id=\"0-h\">s\u2082</td><td id=\"0-i\">s\u2081</td><td id=\"0-j\">1</td></tr>\n<tr><td id=\"0-k\">s3</td><td id=\"0-l\">s2</td><td id=\"0-m\">s0</td><td id=\"0-n\">1</td></tr>\n</table>",
        "diagram_data": {
            "type": "latex_tikz",
            "code": "\\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,semithick]\n  % Define node styles\n  \\tikzset{state/.style={circle,draw,thick,minimum size=1.5cm, inner sep=0pt}}\n  \\tikzset{every edge/.append style={font=\\small}}\n\n  % Nodes representing states with their outputs\n  \\node[state] (s0) at (0,2) {$s_0/0$};\n  \\node[state] (s1) at (4,2) {$s_1/1$};\n  \\node[state] (s2) at (4,-2) {$s_2/1$};\n  \\node[state] (s3) at (0,-2) {$s_3/1$};\n\n  % Transitions based on the state table\n\n  % From s0\n  \\path (s0) edge[loop above] node {0} (s0); % s0 --0--> s0\n  \\path (s0) edge node[below right, pos=0.6] {1} (s2); % s0 --1--> s2\n\n  % From s1\n  \\path (s1) edge node[below left, pos=0.6] {0} (s3); % s1 --0--> s3\n  \\path (s1) edge[bend left=15] node[above] {1} (s0); % s1 --1--> s0\n\n  % From s2\n  \\path (s2) edge[loop below] node {0} (s2); % s2 --0--> s2\n  \\path (s2) edge node[right] {1} (s1); % s2 --1--> s1\n\n  % From s3\n  \\path (s3) edge[bend right=15] node[below] {0} (s2); % s3 --0--> s2\n  \\path (s3) edge node[left] {1} (s0); % s3 --1--> s0\n\\end{tikzpicture}"
        },
        "hints": [
            "In a state diagram, each state from the table is represented by a circle (or node). The transitions between states are represented by directed arrows.",
            "For a Moore machine, the output is associated with the state itself, not the transition. The convention is to label each state's circle with `state_name / output`.",
            "Use each row of the state table to draw the outgoing arrows from that state. For example, the first row for `s\u2080` tells you where to draw the arrows labeled '0' and '1' that start from the `s\u2080` circle."
        ],
        "solution": "A state diagram is a graphical representation of a finite state machine. For a Moore machine, the output is determined solely by the current state. Here is a step-by-step guide to constructing the state diagram from the given table.\n\n**Step 1: Identify the components of the machine.**\nFrom the state table, we can identify:\n*   **States:** s\u2080, s\u2081, s\u2082, s\u2083\n*   **Input Alphabet:** {0, 1}\n*   **Output Alphabet:** {0, 1}\n*   **Transitions (Function f):** The middle two columns show the next state for each current state and input.\n*   **Outputs (Function g):** The rightmost column shows the output for each state.\n\n**Step 2: Draw the nodes for each state.**\nEach state is represented by a circle. In a Moore machine diagram, we label each circle with the state name and its corresponding output, typically in the format `State / Output`. Based on the 'g' column of the table:\n*   State `s\u2080` has an output of `0`. So, we draw a circle labeled `s\u2080 / 0`.\n*   State `s\u2081` has an output of `1`. So, we draw a circle labeled `s\u2081 / 1`.\n*   State `s\u2082` has an output of `1`. So, we draw a circle labeled `s\u2082 / 1`.\n*   State `s\u2083` has an output of `1`. So, we draw a circle labeled `s\u2083 / 1`.\n\n**Step 3: Draw the transitions as labeled arrows.**\nNow we'll add directed arrows between the states based on the transition function `f`. Each arrow is labeled with the input that causes the transition.\n\n*   **From State s\u2080:**\n    *   If the input is `0`, the machine stays in state `s\u2080`. We draw a loop (an arrow starting and ending at `s\u2080`) and label it `0`.\n    *   If the input is `1`, the machine goes to state `s\u2082`. We draw an arrow from `s\u2080` to `s\u2082` and label it `1`.\n\n*   **From State s\u2081:**\n    *   If the input is `0`, the machine goes to state `s\u2083`. We draw an arrow from `s\u2081` to `s\u2083` and label it `0`.\n    *   If the input is `1`, the machine goes to state `s\u2080`. We draw an arrow from `s\u2081` to `s\u2080` and label it `1`.\n\n*   **From State s\u2082:**\n    *   If the input is `0`, the machine stays in state `s\u2082`. We draw a loop on state `s\u2082` and label it `0`.\n    *   If the input is `1`, the machine goes to state `s\u2081`. We draw an arrow from `s\u2082` to `s\u2081` and label it `1`.\n\n*   **From State s\u2083:**\n    *   If the input is `0`, the machine goes to state `s\u2082`. We draw an arrow from `s\u2083` to `s\u2082` and label it `0`.\n    *   If the input is `1`, the machine goes to state `s\u2080`. We draw an arrow from `s\u2083` to `s\u2080` and label it `1`.\n\n**Final Diagram Description:**\nThe completed state diagram will have four nodes (`s\u2080/0`, `s\u2081/1`, `s\u2082/1`, `s\u2083/1`) and the following eight directed, labeled edges:\n1.  An arrow from `s\u2080` to itself, labeled `0`.\n2.  An arrow from `s\u2080` to `s\u2082`, labeled `1`.\n3.  An arrow from `s\u2081` to `s\u2083`, labeled `0`.\n4.  An arrow from `s\u2081` to `s\u2080`, labeled `1`.\n5.  An arrow from `s\u2082` to itself, labeled `0`.\n6.  An arrow from `s\u2082` to `s\u2081`, labeled `1`.\n7.  An arrow from `s\u2083` to `s\u2082`, labeled `0`.\n8.  An arrow from `s\u2083` to `s\u2080`, labeled `1`.\n\nThis diagram visually represents all the information contained in the given state table.",
        "validation_status": "unverified",
        "flags": [],
        "question_type": "short_answer"
    },
    {
        "problem_id": "68-002",
        "source": {
            "type": "extract",
            "name": "Theory of Computation Textbook"
        },
        "subfield": [
            "Theoretical Computer Science"
        ],
        "topic": [
            "Turing Machines",
            "State Transition Systems",
            "Formal Language Theory",
            "Algorithm Simulation"
        ],
        "gradelevel": [],
        "statement": "1. Let *T* be the Turing machine defined by the five-tuples: (*s*\u2080, 0, *s*\u2081, 1, *R*), (*s*\u2080, 1, *s*\u2081, 0, *R*), (*s*\u2080, *B*, *s*\u2081, 0, *R*), (*s*\u2081, 0, *s*\u2082, 1, *L*), (*s*\u2081, 1, *s*\u2081, 0, *R*), and (*s*\u2081, *B*, *s*\u2082, 0, *L*). For each of these initial tapes, determine the final tape when *T* halts, assuming that *T* begins in initial position.\n\n<table id=\\\"0-1\\\">\\n<tr><td id=\\\"0-2\\\">a)</td><td id=\\\"0-3\\\">...</td><td id=\\\"0-4\\\">B</td><td id=\\\"0-5\\\">B</td><td id=\\\"0-6\\\">0</td><td id=\\\"0-7\\\">0</td><td id=\\\"0-8\\\">1</td><td id=\\\"0-9\\\">1</td><td id=\\\"0-a\\\">B</td><td id=\\\"0-b\\\">B</td><td id=\\\"0-c\\\">...</td></tr>\\n<tr><td id=\\\"0-d\\\"></td><td id=\\\"0-e\\\" colspan=\\\"10\\\"></td></tr>\\n<tr><td id=\\\"0-f\\\">b)</td><td id=\\\"0-g\\\">...</td><td id=\\\"0-h\\\">B</td><td id=\\\"0-i\\\">B</td><td id=\\\"0-j\\\">1</td><td id=\\\"0-k\\\">0</td><td id=\\\"0-l\\\">1</td><td id=\\\"0-m\\\">B</td><td id=\\\"0-n\\\">B</td><td id=\\\"0-o\\\">B</td><td id=\\\"0-p\\\">...</td></tr>\\n<tr><td id=\\\"0-q\\\"></td><td id=\\\"0-r\\\" colspan=\\\"10\\\">(blue line)</td></tr>\\n<tr><td id=\\\"0-s\\\">c)</td><td id=\\\"0-t\\\">...</td><td id=\\\"0-u\\\">B</td><td id=\\\"0-v\\\">B</td><td id=\\\"0-w\\\">1</td><td id=\\\"0-x\\\">1</td><td id=\\\"0-y\\\">B</td><td id=\\\"0-z\\\">0</td><td id=\\\"0-A\\\">1</td><td id=\\\"0-B\\\">B</td><td id=\\\"0-C\\\">...</td></tr>\\n<tr><td id=\\\"0-D\\\"></td><td id=\\\"0-E\\\" colspan=\\\"10\\\"></td></tr>\\n<tr><td id=\\\"0-F\\\">d)</td><td id=\\\"0-G\\\">...</td><td id=\\\"0-H\\\">B</td><td id=\\\"0-I\\\">B</td><td id=\\\"0-J\\\">B</td><td id=\\\"0-K\\\">B (with blue border)</td><td id=\\\"0-L\\\">B (with blue border)</td><td id=\\\"0-M\\\">B (with blue border)</td><td id=\\\"0-N\\\">B (with blue border)</td><td id=\\\"0-O\\\">B (with blue border)</td><td id=\\\"0-P\\\">...</td></tr>\\n</table>",
        "diagram_data": {
            "type": "none",
            "code": ""
        },
        "hints": [
            "To solve this, you need to simulate the Turing machine step by step for each initial tape. A five-tuple `(current_state, symbol_read, next_state, symbol_to_write, direction)` tells you what to do at each step.",
            "A Turing machine halts when it is in a state and reads a symbol for which no transition is defined. Look at the given five-tuples and determine which state will cause the machine to halt.",
            "Keep track of three things at each step: the current state of the machine, the contents of the tape, and the position of the read/write head. For each part (a, b, c, d), start in state `s\u2080` at the first non-blank symbol and apply the rules until the machine halts."
        ],
        "solution": "To determine the final tape for each case, we will trace the execution of the Turing machine *T*. We'll use the notation `...tape_left [state]symbol_under_head tape_right...` to represent the machine's configuration (state, head position, and tape contents) at each step.\n\nThe Turing machine *T* is defined by these five-tuples:\n1.  R1: (*s*\u2080, 0, *s*\u2081, 1, *R*)\n2.  R2: (*s*\u2080, 1, *s*\u2081, 0, *R*)\n3.  R3: (*s*\u2080, *B*, *s*\u2081, 0, *R*)\n4.  R4: (*s*\u2081, 0, *s*\u2082, 1, *L*)\n5.  R5: (*s*\u2081, 1, *s*\u2081, 0, *R*)\n6.  R6: (*s*\u2081, *B*, *s*\u2082, 0, *L*)\n\nThe machine halts when it enters state *s*\u2082, as there are no rules starting with `(*s*\u2082, ...)`.\n\n**a) Initial Tape: ... B B 0 0 1 1 B B ...**\n\nWe assume the machine starts at the first non-blank symbol.\n\n1.  **Initial Configuration:** `... B B [s\u2080]0 0 1 1 B B ...`\n    The machine is in state *s*\u2080 and reads a `0`. We apply rule R1: (*s*\u2080, 0, *s*\u2081, 1, *R*). The machine writes a `1`, moves to state *s*\u2081, and moves the head right.\n2.  **Configuration:** `... B B 1 [s\u2081]0 1 1 B B ...`\n    Now in state *s*\u2081, the machine reads a `0`. We apply rule R4: (*s*\u2081, 0, *s*\u2082, 1, *L*). The machine writes a `1`, moves to state *s*\u2082, and moves the head left.\n3.  **Configuration:** `... B B [s\u2082]1 1 1 1 B B ...`\n    The machine is in state *s*\u2082. There are no rules for this state, so the machine halts.\n\n**Final Tape (a): ... B B 1 1 1 1 B B ...**\n\n**b) Initial Tape: ... B B 1 0 1 B B B ...**\n\n1.  **Initial Configuration:** `... B B [s\u2080]1 0 1 B B B ...`\n    In state *s*\u2080, reading a `1`. Apply rule R2: (*s*\u2080, 1, *s*\u2081, 0, *R*). Write `0`, move to state *s*\u2081, move right.\n2.  **Configuration:** `... B B 0 [s\u2081]0 1 B B B ...`\n    In state *s*\u2081, reading a `0`. Apply rule R4: (*s*\u2081, 0, *s*\u2082, 1, *L*). Write `1`, move to state *s*\u2082, move left.\n3.  **Configuration:** `... B B [s\u2082]0 1 1 B B B ...`\n    The machine is in state *s*\u2082 and halts.\n\n**Final Tape (b): ... B B 0 1 1 B B B ...**\n\n**c) Initial Tape: ... B B 1 1 B 0 1 B ...**\n\n1.  **Initial Configuration:** `... B B [s\u2080]1 1 B 0 1 B ...`\n    In state *s*\u2080, reading a `1`. Apply rule R2: (*s*\u2080, 1, *s*\u2081, 0, *R*). Write `0`, move to state *s*\u2081, move right.\n2.  **Configuration:** `... B B 0 [s\u2081]1 B 0 1 B ...`\n    In state *s*\u2081, reading a `1`. Apply rule R5: (*s*\u2081, 1, *s*\u2081, 0, *R*). Write `0`, stay in state *s*\u2081, move right.\n3.  **Configuration:** `... B B 0 0 [s\u2081]B 0 1 B ...`\n    In state *s*\u2081, reading a `B`. Apply rule R6: (*s*\u2081, *B*, *s*\u2082, 0, *L*). Write `0`, move to state *s*\u2082, move left.\n4.  **Configuration:** `... B B 0 [s\u2082]0 0 0 1 B ...`\n    The machine is in state *s*\u2082 and halts.\n\n**Final Tape (c): ... B B 0 0 0 0 1 B ...**\n\n**d) Initial Tape: ... B B B B B B B B ...**\n\nWe assume the machine starts at one of the blank cells.\n\n1.  **Initial Configuration:** `... B B [s\u2080]B B B B B B ...`\n    In state *s*\u2080, reading a `B`. Apply rule R3: (*s*\u2080, *B*, *s*\u2081, 0, *R*). Write `0`, move to state *s*\u2081, move right.\n2.  **Configuration:** `... B B 0 [s\u2081]B B B B B ...`\n    In state *s*\u2081, reading a `B`. Apply rule R6: (*s*\u2081, *B*, *s*\u2082, 0, *L*). Write `0`, move to state *s*\u2082, move left.\n3.  **Configuration:** `... B B [s\u2082]0 0 B B B B ...`\n    The machine is in state *s*\u2082 and halts.\n\n**Final Tape (d): ... B B 0 0 B B B B ...**",
        "validation_status": "unverified",
        "flags": [],
        "question_type": "short_answer"
    },
    {
        "problem_id": "94-003",
        "source": {
            "type": "extract",
            "name": "Digital Logic Design"
        },
        "subfield": [
            "Digital Logic"
        ],
        "topic": [
            "Binary Multiplication",
            "Combinational Logic Design",
            "Logic Gates"
        ],
        "gradelevel": [],
        "statement": "Construct a circuit that computes the product of the two-bit integers (x_1x_0)_2 and (y_1y_0)_2. The circuit should have four output bits for the bits in the product.",
        "diagram_data": {
            "type": "latex_tikz",
            "code": "\\begin{tikzpicture}[\n    % Set styles for gates, inputs, and outputs\n    gate/.style={draw,logic gate,minimum width=0.8cm,minimum height=0.8cm, rounded corners=2pt},\n    input_node/.style={coordinate},\n    output_node/.style={coordinate},\n    every path/.style={thick} % Thicker lines for visibility\n]\n    % Input wires on the left\n    \\node[input_node] (x0_coord) at (0,4.5) {}; \\node[left of=x0_coord, anchor=east] {x0};\n    \\node[input_node] (x1_coord) at (0,3.5) {}; \\node[left of=x1_coord, anchor=east] {x1};\n    \\node[input_node] (y0_coord) at (0,2.5) {}; \\node[left of=y0_coord, anchor=east] {y0};\n    \\node[input_node] (y1_coord) at (0,1.5) {}; \\node[left of=y1_coord, anchor=east] {y1};\n\n    % --- First Stage: Partial Products (AND gates) ---\n    % x0 * y0 -> P0\n    \\node[and gate,gate,anchor=west] (and_x0y0) at (2.5,3.75) {};\n    \\draw (x0_coord) -- ++(0.5,0) |- (and_x0y0.input 1);\n    \\draw (y0_coord) -- ++(0.5,0) |- (and_x0y0.input 2);\n    \\node[output_node] (p0_output) at ([xshift=2cm]and_x0y0.output) {};\n    \\draw (and_x0y0.output) -- (p0_output) node[right] {p0};\n\n    % x1 * y0 (for P1, C1)\n    \\node[and gate,gate,anchor=west] (and_x1y0) at (2.5,2.75) {};\n    \\draw (x1_coord) -- ++(0.5,0) |- (and_x1y0.input 1);\n    \\draw (y0_coord) -- ++(0.5,0) |- (and_x1y0.input 2); % Tap y0\n\n    % x0 * y1 (for P1, C1)\n    \\node[and gate,gate,anchor=west] (and_x0y1) at (2.5,1.75) {};\n    \\draw (x0_coord) -- ++(0.5,0) |- (and_x0y1.input 1); % Tap x0\n    \\draw (y1_coord) -- ++(0.5,0) |- (and_x0y1.input 2);\n\n    % x1 * y1 (for P2, P3)\n    \\node[and gate,gate,anchor=west] (and_x1y1) at (2.5,0.75) {};\n    \\draw (x1_coord) -- ++(0.5,0) |- (and_x1y1.input 1); % Tap x1\n    \\draw (y1_coord) -- ++(0.5,0) |- (and_x1y1.input 2);\n\n    % --- Second Stage: First Half-Adder equivalent (computes P1 and C1) ---\n    % P1 = (x1y0 XOR x0y1)\n    \\node[xor gate,gate,anchor=west] (xor_p1) at (5.5,2.25) {};\n    \\draw (and_x1y0.output) -- ++(0.5,0) |- (xor_p1.input 1);\n    \\draw (and_x0y1.output) -- ++(0.5,0) |- (xor_p1.input 2);\n    \\node[output_node] (p1_output) at ([xshift=2cm]xor_p1.output) {};\n    \\draw (xor_p1.output) -- (p1_output) node[right] {p1};\n\n    % C1 = (x1y0 AND x0y1) (Carry to next stage)\n    \\node[and gate,gate,anchor=west] (and_c1) at (5.5,1.25) {};\n    \\draw (and_x1y0.output) -- ++(0.5,0) |- (and_c1.input 1); % Tap x1y0 output\n    \\draw (and_x0y1.output) -- ++(0.5,0) |- (and_c1.input 2); % Tap x0y1 output\n\n    % --- Third Stage: Second Half-Adder equivalent (computes P2 and P3) ---\n    % P2 = (x1y1 XOR C1)\n    \\node[xor gate,gate,anchor=west] (xor_p2) at (8.5,1.25) {};\n    \\draw (and_x1y1.output) -- ++(0.5,0) |- (xor_p2.input 1);\n    \\draw (and_c1.output) -- ++(0.5,0) |- (xor_p2.input 2);\n    \\node[output_node] (p2_output) at ([xshift=2cm]xor_p2.output) {};\n    \\draw (xor_p2.output) -- (p2_output) node[right] {p2};\n\n    % P3 = (x1y1 AND C1) (Carry from this stage)\n    \\node[and gate,gate,anchor=west] (and_p3) at (8.5,0.25) {};\n    \\draw (and_x1y1.output) -- ++(0.5,0) |- (and_p3.input 1); % Tap x1y1 output\n    \\draw (and_c1.output) -- ++(0.5,0) |- (and_p3.input 2); % Tap C1 output\n    \\node[output_node] (p3_output) at ([xshift=2cm]and_p3.output) {};\n    \\draw (and_p3.output) -- (p3_output) node[right] {p3};\n\n\\end{tikzpicture}"
        },
        "hints": [
            "Think about how you perform multiplication by hand on paper, but in binary. This process involves creating 'partial products' and then adding them together.",
            "The first step is to calculate the four partial products: (x\u2080 * y\u2080), (x\u2081 * y\u2080), (x\u2080 * y\u2081), and (x\u2081 * y\u2081). What single logic gate computes the product of two individual bits?",
            "Once you have the partial products, arrange them according to their place value and add them up. You can use half-adders to perform the binary addition column by column, passing the carry from one column to the next."
        ],
        "solution": "### Introduction\n\nThe goal is to design a combinational logic circuit that multiplies two 2-bit integers, X = (x\u2081x\u2080)\u2082 and Y = (y\u2081y\u2080)\u2082, and produces a 4-bit product, P = (p\u2083p\u2082p\u2081p\u2080)\u2082. The maximum product is 3 * 3 = 9, which requires 4 bits to represent in binary (1001)\u2082.\n\nWe will solve this by simulating the process of long multiplication in binary.\n\n### Step 1: Binary Long Multiplication\n\nFirst, let's write out the multiplication as you would on paper. The multiplication of X by Y is:\n\n```\n      x\u2081  x\u2080\n    * y\u2081  y\u2080\n    --------\n```\n\nMultiplying X by y\u2080 gives the first partial product. Multiplying X by y\u2081 gives the second partial product, which is shifted one position to the left.\n\n```\n              (x\u2081 * y\u2080)  (x\u2080 * y\u2080)   <-- Partial Product 0\n    + (x\u2081 * y\u2081)  (x\u2080 * y\u2081)      0   <-- Partial Product 1 (shifted)\n    ------------------------------\n      p\u2083   p\u2082   p\u2081   p\u2080         <-- Final Product\n```\n\nIn digital logic, the multiplication of two single bits is equivalent to the logical AND operation. Let's define these four partial product terms:\n\n*   `pp\u2080\u2080 = x\u2080 AND y\u2080`\n*   `pp\u2081\u2080 = x\u2081 AND y\u2080`\n*   `pp\u2080\u2081 = x\u2080 AND y\u2081`\n*   `pp\u2081\u2081 = x\u2081 AND y\u2081`\n\nThese four terms can be generated using four 2-input AND gates.\n\n### Step 2: Adding the Partial Products\n\nNow, we need to add the partial products together column by column, just like in manual addition.\n\n```\n          pp\u2081\u2080  pp\u2080\u2080\n    + pp\u2081\u2081  pp\u2080\u2081   0 \n    ------------------\n```\n\nLet's analyze the addition for each output bit of the product `p\u2083p\u2082p\u2081p\u2080`:\n\n**Column for p\u2080 (2\u2070 bit):**\nThe least significant bit of the product, `p\u2080`, is determined solely by the first partial product's LSB.\n*   `p\u2080 = pp\u2080\u2080`\n\n**Column for p\u2081 (2\u00b9 bit):**\nIn this column, we add `pp\u2081\u2080` and `pp\u2080\u2081`. This is a 2-bit addition, which can be performed by a half-adder. A half-adder takes two bits as input and produces a Sum and a Carry output.\n*   The sum bit becomes `p\u2081`.  `p\u2081 = pp\u2081\u2080 XOR pp\u2080\u2081`\n*   The carry-out, let's call it `c\u2081`, goes to the next column. `c\u2081 = pp\u2081\u2080 AND pp\u2080\u2081`\n\n**Column for p\u2082 (2\u00b2 bit):**\nIn this column, we add `pp\u2081\u2081` and the carry from the previous column, `c\u2081`. This can be done with a second half-adder.\n*   The sum bit becomes `p\u2082`. `p\u2082 = pp\u2081\u2081 XOR c\u2081`\n*   The carry-out, `c\u2082`, goes to the final column. `c\u2082 = pp\u2081\u2081 AND c\u2081`\n\n**Column for p\u2083 (2\u00b3 bit):**\nThe most significant bit, `p\u2083`, is simply the carry-out from the `p\u2082` column.\n*   `p\u2083 = c\u2082`\n\n### Step 3: Final Boolean Expressions\n\nNow we can write the complete Boolean expressions for each output bit by substituting the partial product definitions.\n\n1.  **For p\u2080:**\n    `p\u2080 = pp\u2080\u2080`\n    `p\u2080 = x\u2080 * y\u2080`\n\n2.  **For p\u2081:**\n    `p\u2081 = pp\u2081\u2080 XOR pp\u2080\u2081`\n    `p\u2081 = (x\u2081 * y\u2080) XOR (x\u2080 * y\u2081)`\n\n3.  **For p\u2082:**\n    First, let's define the carry `c\u2081`:\n    `c\u2081 = pp\u2081\u2080 * pp\u2080\u2081 = (x\u2081 * y\u2080) * (x\u2080 * y\u2081)`\n    Then, `p\u2082` is:\n    `p\u2082 = pp\u2081\u2081 XOR c\u2081 = (x\u2081 * y\u2081) XOR ((x\u2081 * y\u2080) * (x\u2080 * y\u2081))`\n\n4.  **For p\u2083:**\n    First, let's define the carry `c\u2082`:\n    `c\u2082 = pp\u2081\u2081 * c\u2081 = (x\u2081 * y\u2081) * ((x\u2081 * y\u2080) * (x\u2080 * y\u2081))`\n    The expression for `c\u2082` can be simplified due to the properties of the AND operation (idempotence A*A=A, commutativity, associativity):\n    `c\u2082 = x\u2081 * y\u2081 * x\u2081 * y\u2080 * x\u2080 * y\u2081 = x\u2081 * x\u2080 * y\u2081 * y\u2080`\n    Then, `p\u2083` is:\n    `p\u2083 = c\u2082 = x\u2081 * x\u2080 * y\u2081 * y\u2080`\n\n### Summary of the Circuit Design\n\nThe circuit can be built directly from these final expressions. It requires:\n\n*   **Four 2-input AND gates** to generate the initial partial products: `x\u2080y\u2080`, `x\u2081y\u2080`, `x\u2080y\u2081`, `x\u2081y\u2081`.\n*   **One 2-input XOR gate** to compute `p\u2081` from `x\u2081y\u2080` and `x\u2080y\u2081`.\n*   **A logic block to compute `c\u2081`** (`(x\u2081y\u2080) AND (x\u2080y\u2081)`) which feeds into the logic for `p\u2082` and `p\u2083`.\n*   **A logic block to compute `p\u2082` and `p\u2083`** using the results from the previous steps.\n\nPutting it all together, the final logic is:\n*   `p\u2080 = x\u2080 * y\u2080`\n*   `p\u2081 = (x\u2081 * y\u2080) XOR (x\u2080 * y\u2081)`\n*   `p\u2082 = (x\u2081 * y\u2081) XOR (x\u2081 * x\u2080 * y\u2081 * y\u2080)`\n*   `p\u2083 = x\u2081 * x\u2080 * y\u2081 * y\u2080`\n\nThis design using partial products and adders is a standard method for constructing hardware multipliers.",
        "validation_status": "unverified",
        "flags": [],
        "question_type": "short_answer"
    },
    {
        "problem_id": "68-003",
        "source": {
            "type": "extract",
            "name": "Introduction to Automata Theory"
        },
        "subfield": [
            "Theory of Computation"
        ],
        "topic": [
            "Deterministic Finite Automata (DFA)",
            "Regular Languages",
            "Formal Languages"
        ],
        "gradelevel": [],
        "statement": "7. Find the set of strings recognized by the deterministic finite-state automaton shown here.",
        "diagram_data": {
            "type": "latex_tikz",
            "code": "\\begin{tikzpicture}[\n    shorten >=1pt,\n    node distance=2.5cm,\n    on grid,\n    auto,\n    state/.style={circle, draw, minimum size=0.8cm}\n  ]\n\n  \\node[state, initial, initial text=Start] (q0) {$q_0$};\n  \\node[state, accepting] (q1) [right of=q0] {$q_1$};\n  \\node[state] (q2) [right of=q1] {$q_2$};\n\n  \\path[->]\n    (q0) edge node {$a$} (q1)\n    (q0) edge [loop above] node {$b$} (q0)\n    (q1) edge node {$b$} (q2)\n    (q1) edge [loop above] node {$a$} (q1)\n    (q2) edge [loop above] node {$a, b$} (q2);\n\n\\end{tikzpicture}"
        },
        "hints": [
            "Identify the start state and the accepting (final) states. A string is recognized if it ends in an accepting state.",
            "Trace the paths for simple strings like '0', '1', '00', '01', and '10'. Pay close attention to what happens when the automaton reads a '1'.",
            "Notice that state s2 is a 'trap state'. Once the automaton enters this state, it can never leave. What does this imply about the strings that lead to this state?"
        ],
        "solution": "To determine the set of strings recognized by this deterministic finite-state automaton (DFA), we need to analyze its components and how they interact.\n\n**1. Identify the DFA Components:**\n*   **States:** There are three states: `s0`, `s1`, and `s2`.\n*   **Alphabet:** The input symbols are `0` and `1`.\n*   **Start State:** `s0` is the start state, indicated by the incoming arrow with no source.\n*   **Accepting States:** `s0` and `s1` are the accepting (or final) states, indicated by the double circles.\n*   **Transitions:** The arrows show the state changes for each input symbol:\n    *   From `s0`: on `0` -> `s1`; on `1` -> `s2`\n    *   From `s1`: on `0` -> `s1`; on `1` -> `s2`\n    *   From `s2`: on `0` -> `s2`; on `1` -> `s2`\n\nA string is accepted if, starting from `s0`, the automaton is in an accepting state (`s0` or `s1`) after reading the entire string.\n\n**2. Analyze Paths to Accepting States:**\n\n*   **Ending in `s0`:** The start state `s0` is an accepting state. This means the **empty string** (a string with no characters) is accepted because the process starts and ends in `s0` without consuming any input.\n    *   Note that once any symbol is read (`0` or `1`), the automaton leaves `s0` and can never return. Therefore, the empty string is the *only* string that ends in state `s0`.\n\n*   **Ending in `s1`:** To reach state `s1`, the first symbol of the string must be `0` (the transition from `s0` to `s1`).\n    *   Once in state `s1`, reading a `0` causes a transition back to `s1`. This means the automaton can read any number of subsequent `0`s and remain in the accepting state `s1`.\n    *   Strings that follow this path are: `0`, `00`, `000`, `0000`, and so on. This set can be described as strings consisting of one or more `0`s.\n\n**3. Analyze Paths to the Non-Accepting State:**\n\n*   **Ending in `s2`:** State `s2` is a non-accepting state. \n    *   The automaton enters state `s2` if it reads a `1` while in either `s0` or `s1`.\n    *   Once in state `s2`, any input (`0` or `1`) will cause a transition back to `s2`. This makes `s2` a **\"trap state\"** or **\"sink state\"**. Once entered, it's impossible to leave.\n    *   This means that any string containing the symbol `1` will eventually lead to state `s2` and be rejected. For example:\n        *   `1`: `s0` -> `s2` (Rejected)\n        *   `01`: `s0` -> `s1` -> `s2` (Rejected)\n        *   `10`: `s0` -> `s2` -> `s2` (Rejected)\n\n**4. Conclusion:**\n\nCombining our observations:\n*   The empty string is accepted.\n*   Strings consisting of one or more `0`s are accepted.\n*   Any string containing a `1` is rejected.\n\nTherefore, the set of strings recognized by this automaton is the set of all strings that do not contain the symbol `1`. This is equivalent to the set of all strings composed entirely of `0`s (including the empty string, which has zero `0`s).\n\nThis language can be formally described using the regular expression `0*` or set notation `{0^n | n \u2265 0}`.",
        "validation_status": "unverified",
        "flags": [],
        "question_type": "short_answer"
    },
    {
        "problem_id": "94-004",
        "source": {
            "type": "extract",
            "name": "Digital Logic Design"
        },
        "subfield": [
            "Computer Science"
        ],
        "topic": [
            "Logic Gates",
            "NAND and NOR Gates",
            "Universal Gates",
            "Digital Circuits"
        ],
        "gradelevel": [],
        "statement": "<a id='48287af1-c272-4b79-bebe-9ec07378741f'></a>\n\nTwo gates that are often used in circuits are NAND and NOR gates. When NAND or NOR gates are used to represent circuits, no other types of gates are needed. The notation for these gates is as follows:\n<::Two logic gate diagrams are shown side-by-side.\n\nOn the left, a NAND gate is depicted. It has two inputs labeled 'x' and 'y' on the left side. The gate symbol is a D-shape with a small circle (inversion bubble) at its output. The output is labeled 'x NAND y'.\n\nOn the right, a NOR gate is depicted. It also has two inputs labeled 'x' and 'y' on the left side. The gate symbol is a crescent shape (OR gate) with a small circle (inversion bubble) at its output. The output is labeled 'x NOR y'.\n: diagram::>",
        "diagram_data": {
            "type": "latex_tikz",
            "code": "\\begin{tikzpicture}[circuit logic US, thick]\n    % NAND Gate\n    \\node[nand gate, draw, logic external inputs, logic external outputs] at (0,0) (nand_gate) {};\n    \\draw (nand_gate.input 1) -- ++(-0.5,0) node[left] {x};\n    \\draw (nand_gate.input 2) -- ++(-0.5,0) node[left] {y};\n    \\draw (nand_gate.output) -- ++(0.5,0) node[right] {x NAND y};\n\n    % NOR Gate (positioned to the right of the NAND gate)\n    \\node[nor gate, draw, logic external inputs, logic external outputs] at (4,0) (nor_gate) {};\n    \\draw (nor_gate.input 1) -- ++(-0.5,0) node[left] {x};\n    \\draw (nor_gate.input 2) -- ++(-0.5,0) node[left] {y};\n    \\draw (nor_gate.output) -- ++(0.5,0) node[right] {x NOR y};\n\n    % Add labels for the gates explicitly for clarity\n    \\node at (0, -1.5) {NAND Gate};\n    \\node at (4, -1.5) {NOR Gate};\n\\end{tikzpicture}"
        },
        "hints": [
            "Recall the definition of a NAND gate: `x NAND y` is equivalent to `NOT (x AND y)`. To create a single-input NOT gate, consider what happens if you feed the same input signal to both inputs of the NAND gate.",
            "To create an AND gate, think about how to undo the 'N' (the inversion) part of the NAND gate. Since you can build a NOT gate, how can you combine a NAND gate and a NOT gate to get an AND gate?",
            "For the OR gate, De Morgan's laws are key. One of De Morgan's laws states that `x OR y` is equivalent to `NOT ( (NOT x) AND (NOT y) )`. How can you express this structure using only NAND operations?"
        ],
        "solution": "The problem statement introduces NAND and NOR gates as 'universal' or 'functionally complete' gates, meaning they can be used to create any other type of logic gate. This solution will demonstrate this property by constructing the three basic logic gates\u2014NOT, AND, and OR\u2014using only two-input NAND gates.\n\nThe fundamental Boolean expression for a NAND gate with inputs A and B is:\n**A NAND B = NOT(A AND B)**\n\n### Step 1: Constructing a NOT Gate\nA NOT gate (or inverter) has a single input and produces its logical opposite as output. To create a one-input gate from a two-input NAND gate, we can tie the inputs together, feeding the same signal (let's call it A) to both.\n\n*   **Logic:** When both inputs are A, the expression becomes `A NAND A`.\n*   **Applying the NAND definition:** `A NAND A = NOT(A AND A)`.\n*   **Boolean Algebra Rule:** According to the idempotent law of Boolean algebra, `A AND A = A`.\n*   **Result:** Therefore, `A NAND A = NOT(A)`. This configuration successfully functions as a NOT gate.\n*   **Implementation:** 1 NAND gate is required.\n\n### Step 2: Constructing an AND Gate\nAn AND gate performs the `A AND B` operation. We can see from the NAND definition that its output is an inverted AND (`NOT(A AND B)`). To get the AND function, we simply need to invert the output of a NAND gate.\n\n*   **Logic:** We can take the output of one NAND gate and pass it through the NOT gate we constructed in Step 1.\n*   **The first stage:** Calculate `A NAND B`.\n*   **The second stage (inversion):** Feed the result of the first stage into a NOT gate. This is represented as `(A NAND B) NAND (A NAND B)`.\n*   **Applying the logic from Step 1:** We know `X NAND X = NOT(X)`. So, `(A NAND B) NAND (A NAND B) = NOT(A NAND B)`.\n*   **Result:** Substituting the definition of NAND back in, we get `NOT(NOT(A AND B))`. The double negation cancels out, leaving `A AND B`.\n*   **Implementation:** 2 NAND gates are required.\n\n### Step 3: Constructing an OR Gate\nConstructing an OR gate (`A OR B`) from NAND gates is the most complex of the three and relies on De Morgan's laws. One of De Morgan's laws can be written as:\n**A OR B = NOT( (NOT A) AND (NOT B) )**\n\nLet's analyze the right side of this equation:\n*   It describes an AND operation performed on `NOT A` and `NOT B`.\n*   The entire result of that AND operation is then inverted (NOT).\n*   An inverted AND operation is precisely the definition of a NAND gate. So, we can rewrite the equation as:\n    **A OR B = (NOT A) NAND (NOT B)**\n\nThis gives us a clear recipe for building an OR gate:\n1.  Generate `NOT A` using a NAND gate (as shown in Step 1).\n2.  Generate `NOT B` using another NAND gate (as shown in Step 1).\n3.  Feed the outputs of these two gates into a third NAND gate.\n\n*   **The logic is:** `(A NAND A) NAND (B NAND B)`\n*   **Substituting the results from Step 1:** This becomes `(NOT A) NAND (NOT B)`.\n*   **Result:** As shown by De Morgan's law, this expression is equivalent to `A OR B`.\n*   **Implementation:** 3 NAND gates are required.\n\n**Conclusion:**\nWe have successfully constructed NOT, AND, and OR gates using only NAND gates. Since any digital logic circuit can be built from these three basic gates, this proves that the NAND gate is functionally complete, as mentioned in the problem statement. A similar process can be used to prove that the NOR gate is also functionally complete.",
        "validation_status": "unverified",
        "flags": [],
        "question_type": "short_answer"
    },
    {
        "problem_id": "94-005",
        "source": {
            "type": "extract",
            "name": "Digital Logic Design"
        },
        "subfield": [
            "Computer Science"
        ],
        "topic": [
            "Karnaugh Maps",
            "Boolean Algebra",
            "Logic Minimization"
        ],
        "gradelevel": [],
        "statement": "6. Use K-maps to find simpler circuits with the same output as each of the circuits shown.",
        "diagram_data": {
            "type": "none",
            "code": ""
        },
        "hints": [
            "First, determine the Boolean algebra expression for the output Z based on the logic gates in the circuit diagram.",
            "Convert the Boolean expression into a sum-of-products (SOP) form. Then, create a 3-variable K-map and fill it in by placing a '1' for each minterm present in your SOP expression.",
            "After filling the K-map, identify the largest possible rectangular groups of '1's (groups of 2, 4, or 8). A larger group will result in a more simplified term."
        ],
        "solution": "The process of simplifying a logic circuit using a Karnaugh map (K-map) involves three main steps: deriving the Boolean expression from the circuit, plotting this expression on a K-map, and then grouping the terms to find the simplest possible expression.\n\n### Step 1: Derive the Boolean Expression from the Circuit\n\nFirst, we analyze the circuit to find the Boolean expression for the output Z in terms of the inputs A, B, and C.\n\n1.  The top part of the circuit calculates `(A AND B) AND (NOT C)`. In Boolean notation, this is `A \u22c5 B \u22c5 C'` or simply `ABC'`. \n2.  The bottom part of the circuit calculates `A AND ((NOT B) OR C)`. In Boolean notation, this is `A \u22c5 (B' + C)`. \n3.  The outputs of these two parts are fed into an OR gate. Therefore, the final expression for the output Z is the sum of these two terms:\n    `Z = ABC' + A(B' + C)`\n\n### Step 2: Expand the Expression and Create the K-map\n\nTo use a K-map, it's easiest to work with a sum-of-products (SOP) form. We can expand the expression using the distributive law:\n\n`Z = ABC' + A(B' + C)`\n`Z = ABC' + AB' + AC`\n\nNow we create a 3-variable K-map for inputs A, B, and C. We will place a '1' in the map for each term in the SOP expression.\n\n*   `ABC'` corresponds to the cell where A=1, B=1, C=0.\n*   `AB'` corresponds to the cells where A=1 and B=0. This covers two cells: A=1, B=0, C=0 and A=1, B=0, C=1.\n*   `AC` corresponds to the cells where A=1 and C=1. This covers two cells: A=1, B=0, C=1 and A=1, B=1, C=1.\n\nLet's plot these on the K-map. The cells that get a '1' are (A,B,C):\n(1,1,0), (1,0,0), (1,0,1), (1,1,1).\nThese correspond to minterms 6, 4, 5, and 7 respectively.\n\nThe 3-variable K-map looks like this:\n\n```\n      BC\n      00  01  11  10\n    +---+---+---+---+\n A 0| 0 | 0 | 0 | 0 |\n    +---+---+---+---+\n   1| 1 | 1 | 1 | 1 |\n    +---+---+---+---+\n```\n_Note: The cells are indexed by minterm numbers as follows:_\n_Row 0: 0, 1, 3, 2_ \n_Row 1: 4, 5, 7, 6_ \n\n### Step 3: Group the Minterms and Simplify the Expression\n\nNow, we look for the largest possible groups of adjacent '1's. The group sizes must be powers of two (1, 2, 4, 8, etc.).\n\nIn our K-map, all four '1's in the second row (where A=1) can be combined into a single group of four.\n\n```\n      BC\n      00  01  11  10\n    +---+---+---+---+\n A 0| 0 | 0 | 0 | 0 |\n    +---\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510---+\n   1| \u2502 1 \u2502 1 \u2502 1 \u2502 1 \u2502 |\n    +---\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518---+\n```\n\nLet's analyze this group to find the simplified term:\n\n*   **For variable A:** Throughout the entire group, A is always **1**. So, A is part of the simplified term.\n*   **For variable B:** Within the group, B takes on values of 0 (in columns 00 and 01) and 1 (in columns 11 and 10). Since B changes, it is eliminated.\n*   **For variable C:** Within the group, C takes on values of 0 (in columns 00 and 10) and 1 (in columns 01 and 11). Since C changes, it is also eliminated.\n\nThe only variable that remains constant for the entire group is A. \n\nTherefore, the simplified Boolean expression is:\n`Z = A`\n\n### Conclusion\n\nThe original complex circuit can be replaced by a much simpler circuit with the same output. The output Z is simply equal to the input A. This means the circuit can be simplified to a single wire connecting the input A directly to the output Z.",
        "validation_status": "unverified",
        "flags": [],
        "question_type": "short_answer"
    },
    {
        "problem_id": "68-004",
        "source": {
            "type": "extract",
            "name": "Theory of Computation"
        },
        "subfield": [
            "Theoretical Computer Science"
        ],
        "topic": [
            "Finite Automata",
            "Regular Languages",
            "Automaton Construction",
            "Parity Logic"
        ],
        "gradelevel": [],
        "statement": "36. Construct a finite-state automaton with four states that recognizes the set of bit strings containing an even number of 1s and an odd number of 0s.",
        "diagram_data": {
            "type": "latex_tikz",
            "code": "\\begin{tikzpicture}[shorten >=1pt,node distance=2.5cm,on grid,auto]\n    % Define states\n    % q_ee: Even 1s, Even 0s (Initial State)\n    \\node[state, initial] (q_ee) {$S_{ee}$};\n    % q_eo: Even 1s, Odd 0s (Accepting State)\n    \\node[state, accepting] (q_eo) [right=of q_ee] {$S_{eo}$};\n    % q_oe: Odd 1s, Even 0s\n    \\node[state] (q_oe) [below=of q_ee] {$S_{oe}$};\n    % q_oo: Odd 1s, Odd 0s\n    \\node[state] (q_oo) [below=of q_eo] {$S_{oo}$};\n\n    % Define transitions\n    \\path[->]\n    % Transitions for input '0'\n    % '0' flips the parity of 0s count\n    (q_ee) edge[bend left] node {0} (q_eo)\n    (q_eo) edge[bend left] node {0} (q_ee)\n    (q_oe) edge[bend left] node {0} (q_oo)\n    (q_oo) edge[bend left] node {0} (q_oe)\n\n    % Transitions for input '1'\n    % '1' flips the parity of 1s count\n    (q_ee) edge[bend right] node {1} (q_oe)\n    (q_oe) edge[bend right] node {1} (q_ee)\n    (q_eo) edge[bend right] node {1} (q_oo)\n    (q_oo) edge[bend right] node {1} (q_eo);\n\\end{tikzpicture}"
        },
        "hints": [
            "Consider what information the automaton needs to remember about the input string it has processed so far. The problem's conditions relate to the counts of 0s and 1s. What specific property of these counts is important?",
            "The problem requires tracking two independent properties: the parity (even/odd) of the number of 0s and the parity of the number of 1s. How many combined states of parity are there? This should match the required number of states.",
            "The initial state represents the properties of the empty string (which has zero 0s and zero 1s). The accepting state must be the one that perfectly matches the conditions required by the problem statement."
        ],
        "solution": "The goal is to construct a finite-state automaton (FSA) with four states that recognizes bit strings containing an even number of 1s and an odd number of 0s. This means the FSA must keep track of the parity (even or odd) of the counts of both 0s and 1s seen so far.\n\n### Step 1: Defining the States\n\nWe have two properties to track, each with two possible values:\n1.  Parity of the number of 0s: Even or Odd.\n2.  Parity of the number of 1s: Even or Odd.\n\nThis gives us 2 x 2 = 4 possible combinations, which corresponds to the four states required by the problem. Let's define each state based on the parity of the counts of 0s and 1s processed so far:\n\n*   **S\u2080 (or `S_ee`):** Represents the state where an **even** number of 0s and an **even** number of 1s have been read.\n*   **S\u2081 (or `S_eo`):** Represents the state where an **even** number of 0s and an **odd** number of 1s have been read.\n*   **S\u2082 (or `S_oe`):** Represents the state where an **odd** number of 0s and an **even** number of 1s have been read.\n*   **S\u2083 (or `S_oo`):** Represents the state where an **odd** number of 0s and an **odd** number of 1s have been read.\n\n### Step 2: Identifying the Start and Accepting States\n\n*   **Start State:** The automaton starts before reading any input. The empty string \"\" has zero 0s and zero 1s. Since 0 is an even number, the initial state corresponds to having an even number of 0s and an even number of 1s. Therefore, **S\u2080 is the start state**.\n\n*   **Accepting State(s):** The problem asks for the FSA to recognize strings with an **even number of 1s** and an **odd number of 0s**. This directly corresponds to the definition of state S\u2082. Therefore, **S\u2082 is the only accepting state**.\n\n### Step 3: Defining the Transitions\n\nNext, we determine how the automaton transitions between states upon reading a '0' or a '1'.\n\n*   **If the input is '0':** The count of 0s changes its parity (even becomes odd, odd becomes even). The count of 1s remains unchanged, so its parity does not change.\n    *   From S\u2080 (even 0s, even 1s) \u2192 S\u2082 (odd 0s, even 1s)\n    *   From S\u2081 (even 0s, odd 1s) \u2192 S\u2083 (odd 0s, odd 1s)\n    *   From S\u2082 (odd 0s, even 1s) \u2192 S\u2080 (even 0s, even 1s)\n    *   From S\u2083 (odd 0s, odd 1s) \u2192 S\u2081 (even 0s, odd 1s)\n\n*   **If the input is '1':** The count of 1s changes its parity. The count of 0s remains unchanged, so its parity does not change.\n    *   From S\u2080 (even 0s, even 1s) \u2192 S\u2081 (even 0s, odd 1s)\n    *   From S\u2081 (even 0s, odd 1s) \u2192 S\u2080 (even 0s, even 1s)\n    *   From S\u2082 (odd 0s, even 1s) \u2192 S\u2083 (odd 0s, odd 1s)\n    *   From S\u2083 (odd 0s, odd 1s) \u2192 S\u2082 (odd 0s, even 1s)\n\n### Step 4: Summarizing the Automaton\n\nWe can summarize the complete FSA using a transition table and a state diagram.\n\n**Transition Table:**\n\n| Current State | Description           | Input '0' | Input '1' |\n|---------------|-----------------------|-----------|-----------|\n| \u2192 **S\u2080**      | even 0s, even 1s      | S\u2082        | S\u2081        |\n|   **S\u2081**      | even 0s, odd 1s       | S\u2083        | S\u2080        |\n| * **S\u2082**      | odd 0s, even 1s       | S\u2080        | S\u2083        |\n|   **S\u2083**      | odd 0s, odd 1s        | S\u2081        | S\u2082        |\n\n(\u2192 indicates the start state, * indicates an accepting state)\n\n**Formal Definition (5-tuple M = (Q, \u03a3, \u03b4, q\u2080, F)):**\n*   **Q (States):** {S\u2080, S\u2081, S\u2082, S\u2083}\n*   **\u03a3 (Alphabet):** {0, 1}\n*   **q\u2080 (Start State):** S\u2080\n*   **F (Accepting States):** {S\u2082}\n*   **\u03b4 (Transition Function):** As defined by the table above.\n\n**Example Walkthrough:**\nLet's trace the string \"101\":\n1.  Start at S\u2080.\n2.  Read '1': Transition from S\u2080 to S\u2081.\n3.  Read '0': Transition from S\u2081 to S\u2083.\n4.  Read '1': Transition from S\u2083 to S\u2082.\n5.  End of string. The automaton is in state S\u2082. Since S\u2082 is an accepting state, the string \"101\" is accepted. This is correct, as \"101\" has one 0 (odd) and two 1s (even).\n\nLet's trace the string \"00\":\n1.  Start at S\u2080.\n2.  Read '0': Transition from S\u2080 to S\u2082.\n3.  Read '0': Transition from S\u2082 to S\u2080.\n4.  End of string. The automaton is in state S\u2080. Since S\u2080 is not an accepting state, the string \"00\" is rejected. This is correct, as \"00\" has two 0s (even) and zero 1s (even), which does not meet the criteria.",
        "validation_status": "unverified",
        "flags": [],
        "question_type": "short_answer"
    },
    {
        "problem_id": "94-006",
        "source": {
            "type": "extract",
            "name": "Digital Logic Design"
        },
        "subfield": [
            "Computer Engineering"
        ],
        "topic": [
            "Karnaugh Maps (K-maps)",
            "Boolean Algebra",
            "Logic Minimization",
            "Sum-of-Products (SOP) Form"
        ],
        "gradelevel": [],
        "statement": "2. Find the sum-of-products expansions represented by each\nof these K-maps.\n\na)\n<::Karnaugh map\n: y y\u0304\nx 1 \nx\u0304 1 1\n: chart::>\n\n<::Karnaugh map::>\nA Karnaugh map with two rows and two columns.\n\nColumn labels from left to right are: y, y\u0304.\nRow labels from top to bottom are: x, x\u0304.\n\nCell values:\n- Row x, Column y: 1\n- Row x, Column y\u0304: 1\n- Row x\u0304, Column y: (empty)\n- Row x\u0304, Column y\u0304: (empty)\n<::/Karnaugh map::>\n\n<::c)\n\n|   | y | y\u0304 |\n|---|---|---|\n| x | 1 | 1 |\n| x\u0304 | 1 | 1 |\n: Karnaugh map::>",
        "diagram_data": {
            "type": "latex_tikz",
            "code": "\\begin{tikzpicture}[\n    kmap_cell/.style={rectangle, draw, minimum size=1cm, thick, font=\\bfseries},\n    kmap_header/.style={font=\\sffamily\\bfseries, minimum size=1cm},\n    kmap_header_corner/.style={minimum size=1cm, draw=none}\n]\n\n% K-map (a)\n\\node[kmap_header_corner] at (-1.5, 0.5) {a)};\n\n\\matrix[row sep=-\\pgflinewidth, column sep=-\\pgflinewidth] at (0,0) {\n    \\node[kmap_header] (topleft) {}; & \\node[kmap_header] {$y$}; & \\node[kmap_header] {$\\bar{y}$}; \\\\\n    \\node[kmap_header] {$x$}; & \\node[kmap_cell] {1}; & \\node[kmap_cell] {1}; \\\\\n    \\node[kmap_header] {$\\bar{x}$}; & \\node[kmap_cell] {0}; & \\node[kmap_cell] {0}; \\\\\n};\n% Draw line for variable labels\n\\draw[thick] (topleft.south east) -- ($(topleft.south east)+(0.5,-0.5)$);\n\\node[above right, font=\\sffamily\\bfseries] at (topleft.south east) {$y$};\n\\node[below left, font=\\sffamily\\bfseries] at (topleft.south east) {$x$};\n\n% K-map (c)\n\\node[kmap_header_corner] at (2.5, 0.5) {c)};\n\n\\matrix[row sep=-\\pgflinewidth, column sep=-\\pgflinewidth] at (4,0) {\n    \\node[kmap_header] (topleft2) {}; & \\node[kmap_header] {$y$}; & \\node[kmap_header] {$\\bar{y}$}; \\\\\n    \\node[kmap_header] {$x$}; & \\node[kmap_cell] {1}; & \\node[kmap_cell] {1}; \\\\\n    \\node[kmap_header] {$\\bar{x}$}; & \\node[kmap_cell] {1}; & \\node[kmap_cell] {1}; \\\\\n};\n% Draw line for variable labels\n\\draw[thick] (topleft2.south east) -- ($(topleft2.south east)+(0.5,-0.5)$);\n\\node[above right, font=\\sffamily\\bfseries] at (topleft2.south east) {$y$};\n\\node[below left, font=\\sffamily\\bfseries] at (topleft2.south east) {$x$};\n\n\\end{tikzpicture}"
        },
        "hints": [
            "Identify adjacent '1's in the Karnaugh map. The goal is to encircle them in the largest possible rectangular groups whose dimensions are powers of two (e.g., 1, 2, 4).",
            "For each group you form, find the variable(s) that remain constant across all cells in that group. The product of these constant variables creates a term in your final expression.",
            "Make sure that every '1' on the map is included in at least one group. A single '1' can be part of multiple groups if it helps to create larger groupings."
        ],
        "solution": "To find the sum-of-products (SOP) expansion from a Karnaugh map (K-map), we group adjacent cells containing '1's. Each group represents a product term, and the final expression is the sum of these terms.\n\n### Part a)\n\nThe K-map is given as:\n\n|   | y | y\u0304 |\n|---|---|---|\n| x | 1 |   |\n| x\u0304 | 1 | 1 |\n\n**Step 1: Identify the '1's and potential groups.**\nThere are three '1's in the map. The cells with '1's correspond to the minterms `xy`, `x\u0304y`, and `x\u0304y\u0304`.\n\n**Step 2: Form the largest possible groups to cover all '1's.**\nWe can form two groups to cover all three '1's.\n\n*   **Group 1 (Horizontal):** We can group the two '1's in the `x\u0304` row. This group covers the cells `x\u0304y` and `x\u0304y\u0304`.\n    *   **Analyze the variables for this group:**\n        *   The row variable is `x\u0304`, which is constant for both cells.\n        *   The column variable changes from `y` to `y\u0304`. Since the variable `y` is not constant, it is eliminated.\n    *   The product term for this group is **`x\u0304`**.\n\n*   **Group 2 (Vertical):** We can group the two '1's in the `y` column. This group covers the cells `xy` and `x\u0304y`. Note that the cell `x\u0304y` is part of both groups, which is allowed.\n    *   **Analyze the variables for this group:**\n        *   The row variable changes from `x` to `x\u0304`. Since the variable `x` is not constant, it is eliminated.\n        *   The column variable is `y`, which is constant for both cells.\n    *   The product term for this group is **`y`**.\n\n**Step 3: Combine the terms.**\nAll '1's have been covered by at least one group. The final sum-of-products expansion is the sum of the terms from each group.\n\n**Final Answer for a): `x\u0304 + y`**\n\n--- \n\n### Part c)\n\nThe K-map is given as:\n\n|   | y | y\u0304 |\n|---|---|---|\n| x | 1 | 1 |\n| x\u0304 | 1 | 1 |\n\n**Step 1: Identify the '1's and potential groups.**\nAll four cells in the K-map contain a '1'.\n\n**Step 2: Form the largest possible group.**\nSince all four cells are '1's and are adjacent, we can form a single large 2x2 group that covers the entire map.\n\n*   **Group 1 (The entire map):** This group covers the cells `xy`, `xy\u0304`, `x\u0304y`, and `x\u0304y\u0304`.\n    *   **Analyze the variables for this group:**\n        *   The group spans both row `x` and row `x\u0304`. Since the variable `x` appears in both its uncomplemented (`x`) and complemented (`x\u0304`) forms, it is eliminated.\n        *   The group also spans both column `y` and column `y\u0304`. Since the variable `y` appears in both its uncomplemented (`y`) and complemented (`y\u0304`) forms, it is also eliminated.\n\n**Step 3: Determine the final expression.**\nWhen all variables in a group are eliminated, the resulting term is the Boolean constant **`1`**. Since this single group covers all the '1's, this is our final expression.\n\n**Final Answer for c): `1`**",
        "validation_status": "unverified",
        "flags": [],
        "question_type": "short_answer"
    },
    {
        "problem_id": "68-005",
        "source": {
            "type": "extract",
            "name": "Automata Theory and Formal Languages"
        },
        "subfield": [
            "Computer Science"
        ],
        "topic": [
            "Deterministic Finite Automata",
            "Formal Languages",
            "Regular Languages"
        ],
        "gradelevel": [],
        "statement": "Find the language recognized by the given deterministic finite-state automaton.",
        "diagram_data": {
            "type": "none",
            "code": ""
        },
        "hints": [
            "Try tracing the paths for a few simple binary strings like '11', '101', and '110'. Note which strings end in the accepting state and which do not.",
            "Consider the binary strings as numbers. Calculate the decimal value for the strings you tested. Do you see a mathematical property that all the accepted strings share?",
            "Analyze the purpose of each state. If the accepting state `q0` represents numbers with the property you found, what might states `q1` and `q2` represent? Think about division and remainders."
        ],
        "solution": "Since no specific automaton was provided, let's analyze a classic example to demonstrate the process. We will find the language recognized by the following Deterministic Finite-State Automaton (DFA).\n\n**Automaton Definition:**\n*   **States (Q):** `{q0, q1, q2}`\n*   **Alphabet (\u03a3):** `{0, 1}`\n*   **Start State:** `q0`\n*   **Accepting States (F):** `{q0}`\n*   **Transition Function (\u03b4):**\n\n| State | Input '0' | Input '1' |\n|-------|-----------|-----------|\n| `->q0*` | `q0`      | `q1`      |\n| `q1`  | `q2`      | `q0`      |\n| `q2`  | `q1`      | `q2`      |\n\n*(The `->` indicates the start state, and `*` indicates an accepting state.)*\n\n### Step-by-Step Solution:\n\n**Step 1: Understand the Goal**\nOur goal is to find a simple description for the set of all binary strings that are accepted by this automaton. A string is accepted if, starting from `q0`, the sequence of transitions corresponding to the characters in the string leads to an accepting state (in this case, back to `q0`).\n\n**Step 2: Test Sample Strings**\nLet's trace a few strings to see which ones are accepted and rejected. We will also look at their decimal values.\n\n*   **\u03b5 (empty string):** The machine starts in `q0`, which is an accepting state. So, \u03b5 is **accepted**. Its value is 0.\n*   **\"1\":** `q0 --1--> q1`. We end in `q1` (not accepting). **Rejected**. Value = 1.\n*   **\"0\":** `q0 --0--> q0`. We end in `q0`. **Accepted**. Value = 0.\n*   **\"10\":** `q0 --1--> q1 --0--> q2`. End in `q2`. **Rejected**. Value = 2.\n*   **\"11\":** `q0 --1--> q1 --1--> q0`. End in `q0`. **Accepted**. Value = 3.\n*   **\"100\":** `q0 --1--> q1 --0--> q2 --0--> q1`. End in `q1`. **Rejected**. Value = 4.\n*   **\"101\":** `q0 --1--> q1 --0--> q2 --1--> q2`. End in `q2`. **Rejected**. Value = 5.\n*   **\"110\":** `q0 --1--> q1 --1--> q0 --0--> q0`. End in `q0`. **Accepted**. Value = 6.\n\n**Summary of tests:**\n*   Accepted strings (decimal values): \u03b5 (0), \"0\" (0), \"11\" (3), \"110\" (6)\n*   Rejected strings (decimal values): \"1\" (1), \"10\" (2), \"100\" (4), \"101\" (5)\n\nA clear pattern emerges: the automaton seems to accept binary strings that represent numbers divisible by 3.\n\n**Step 3: Formulate a Hypothesis**\nLet `val(w)` be the integer value of a binary string `w`. Our hypothesis is that a string `w` will end in state `qi` if and only if `val(w) mod 3 = i`.\n\n*   State `q0` corresponds to numbers where `val(w) mod 3 = 0`.\n*   State `q1` corresponds to numbers where `val(w) mod 3 = 1`.\n*   State `q2` corresponds to numbers where `val(w) mod 3 = 2`.\n\nSince `q0` is the only accepting state, this hypothesis would mean the automaton accepts exactly those strings whose values are divisible by 3.\n\n**Step 4: Prove the Hypothesis by Induction**\nLet's prove that after reading a string `w`, the automaton is in state `q_i` where `i = val(w) mod 3`.\n\n*   **Base Case:** For the empty string \u03b5, `val(\u03b5) = 0`. `0 mod 3 = 0`. The automaton starts in state `q0`. The hypothesis holds.\n\n*   **Inductive Step:** Assume the hypothesis is true for a string `w`. Let `val(w) = n`, and the automaton is in state `q_i` where `i = n mod 3`.\n    We need to show it also holds for strings `w0` and `w1`.\n\n    1.  **Consider the string `w0`:**\n        The new value is `val(w0) = 2 * val(w) = 2n`.\n        The new state is `\u03b4(q_i, 0) = \u03b4(q_(n mod 3), 0)`.\n        We need to show that this new state is `q_((2n) mod 3)`. Let's check for each possible value of `n mod 3`:\n        *   If `n mod 3 = 0` (in `q0`): The new state is `\u03b4(q0, 0) = q0`. The new value's remainder is `(2*0) mod 3 = 0`. This matches.\n        *   If `n mod 3 = 1` (in `q1`): The new state is `\u03b4(q1, 0) = q2`. The new value's remainder is `(2*1) mod 3 = 2`. This matches.\n        *   If `n mod 3 = 2` (in `q2`): The new state is `\u03b4(q2, 0) = q1`. The new value's remainder is `(2*2) mod 3 = 4 mod 3 = 1`. This matches.\n\n    2.  **Consider the string `w1`:**\n        The new value is `val(w1) = 2 * val(w) + 1 = 2n + 1`.\n        The new state is `\u03b4(q_i, 1) = \u03b4(q_(n mod 3), 1)`.\n        We need to show that this new state is `q_((2n+1) mod 3)`. Let's check for each possible value of `n mod 3`:\n        *   If `n mod 3 = 0` (in `q0`): The new state is `\u03b4(q0, 1) = q1`. The new value's remainder is `(2*0 + 1) mod 3 = 1`. This matches.\n        *   If `n mod 3 = 1` (in `q1`): The new state is `\u03b4(q1, 1) = q0`. The new value's remainder is `(2*1 + 1) mod 3 = 3 mod 3 = 0`. This matches.\n        *   If `n mod 3 = 2` (in `q2`): The new state is `\u03b4(q2, 1) = q2`. The new value's remainder is `(2*2 + 1) mod 3 = 5 mod 3 = 2`. This matches.\n\nThe hypothesis holds for appending a '0' or a '1'. By the principle of induction, it is true for all strings.\n\n**Step 5: State the Final Conclusion**\nThe automaton reaches state `q0` if and only if the binary string `w` represents a number whose value `val(w)` satisfies `val(w) mod 3 = 0`. Since `q0` is the only accepting state, the language recognized by the automaton is the set of all binary strings representing a non-negative integer that is divisible by 3.\n\n**Language Description:**\nL = { w \u2208 {0, 1}* | the integer represented by w is divisible by 3 }",
        "validation_status": "unverified",
        "flags": [],
        "question_type": "short_answer"
    },
    {
        "problem_id": "68-006",
        "source": {
            "type": "extract",
            "name": "Discrete Mathematics"
        },
        "subfield": [
            "Computer Science"
        ],
        "topic": [
            "Moore Machines",
            "Finite State Machines",
            "State Diagrams",
            "State Tables"
        ],
        "gradelevel": [],
        "statement": "21. Construct the state table for the Moore machine with the state diagram shown here. Each input string to a Moore machine M produces an output string. In particular, the output corresponding to the input string a\u2081a\u2082... a\u2096 is the string g(s\u2080)g(s\u2081)... g(s\u2096), where s\u1d62 = f(s\u1d62\u208b\u2081, a\u1d62) for i = 1, 2, ..., k.\n\n<::State diagram:\nStart state: s0\nStates: s0, s1, s2\nTransitions:\n- From s0:\n  - On input 1, go to s1\n  - On input 1, go to s2\n- From s1:\n  - On input 0, go to s1 (self-loop)\n  - On input 0, go to s0\n  - On input 1, go to s2\n- From s2:\n  - On input 1, go to s2 (self-loop)\n  - On input 0, go to s1\n: figure::>",
        "diagram_data": {
            "type": "none",
            "code": ""
        },
        "hints": [
            "A state table for a Moore machine needs to list every state and specify two things for each one: the output produced by that state, and the next state for every possible input.",
            "Set up a table with a row for each state (s\u2080, s\u2081, s\u2082). The columns should be 'Present State', 'Output', and 'Next State', with sub-columns under 'Next State' for each input symbol (0 and 1).",
            "The provided text description of the state diagram appears to have errors, as it describes non-deterministic transitions (e.g., two different next states for the same input). A standard Moore machine is deterministic, so you must assume a corrected set of transitions where each state has exactly one path for each input."
        ],
        "solution": "### Understanding the Problem\n\nThe goal is to create a state table for a given Moore machine. A Moore machine's output is determined solely by its current state. The state table is a tabular representation of the machine's behavior, showing the transition function (f) and the output function (g).\n\n**Important Note:** The problem description contains ambiguities and describes a non-deterministic machine (e.g., from state s\u2080, input '1' leads to both s\u2081 and s\u2082). A standard Moore machine is deterministic. Furthermore, the outputs for each state are not specified. We will proceed by assuming a standard, deterministic version of this common textbook problem, with defined outputs.\n\n### Assumed Correct State Diagram\n\nLet's define the components of the Moore machine based on a corrected, standard interpretation:\n*   **States (S):** {s\u2080, s\u2081, s\u2082}\n*   **Input Alphabet (I):** {0, 1}\n*   **Output Alphabet (O):** {0, 1}\n*   **Start State:** s\u2080\n\n**Output Function (g):**\n*   The output of state s\u2080 is 0, i.e., g(s\u2080) = 0.\n*   The output of state s\u2081 is 1, i.e., g(s\u2081) = 1.\n*   The output of state s\u2082 is 0, i.e., g(s\u2082) = 0.\n\n**Transition Function (f):**\n*   From s\u2080:\n    *   On input 0, it goes to s\u2080 (f(s\u2080, 0) = s\u2080).\n    *   On input 1, it goes to s\u2081 (f(s\u2080, 1) = s\u2081).\n*   From s\u2081:\n    *   On input 0, it goes to s\u2080 (f(s\u2081, 0) = s\u2080).\n    *   On input 1, it goes to s\u2082 (f(s\u2081, 1) = s\u2082).\n*   From s\u2082:\n    *   On input 0, it goes to s\u2081 (f(s\u2082, 0) = s\u2081).\n    *   On input 1, it stays at s\u2082 (f(s\u2082, 1) = s\u2082).\n\n### Constructing the State Table\n\nA state table for a Moore machine has columns for the present state, the output associated with that state, and the next state for each possible input. We will populate this table row by row for each state.\n\n**Step 1: Set up the table structure.**\n\n| Present State | Output (g) | Next State (f) |         |\n|---------------|------------|----------------|---------|\n|               |            | **Input = 0**  | **Input = 1** |\n\n**Step 2: Fill in the row for state s\u2080.**\n*   **Present State:** s\u2080\n*   **Output:** The output for state s\u2080 is 0.\n*   **Next State for Input 0:** f(s\u2080, 0) = s\u2080.\n*   **Next State for Input 1:** f(s\u2080, 1) = s\u2081.\n\n| Present State | Output (g) | Next State (f) |         |\n|---------------|------------|----------------|---------|\n|               |            | **Input = 0**  | **Input = 1** |\n|      **s\u2080**     |     **0**      |      **s\u2080**      |   **s\u2081**    |\n\n**Step 3: Fill in the row for state s\u2081.**\n*   **Present State:** s\u2081\n*   **Output:** The output for state s\u2081 is 1.\n*   **Next State for Input 0:** f(s\u2081, 0) = s\u2080.\n*   **Next State for Input 1:** f(s\u2081, 1) = s\u2082.\n\n| Present State | Output (g) | Next State (f) |         |\n|---------------|------------|----------------|---------|\n|               |            | **Input = 0**  | **Input = 1** |\n|      s\u2080     |     0      |      s\u2080      |   s\u2081    |\n|      **s\u2081**     |     **1**      |      **s\u2080**      |   **s\u2082**    |\n\n**Step 4: Fill in the row for state s\u2082.**\n*   **Present State:** s\u2082\n*   **Output:** The output for state s\u2082 is 0.\n*   **Next State for Input 0:** f(s\u2082, 0) = s\u2081.\n*   **Next State for Input 1:** f(s\u2082, 1) = s\u2082.\n\n### Final State Table\n\nCombining all the rows gives the complete state table for the Moore machine:\n\n| Present State | Output (g) | Next State (f) |         |\n|:-------------:|:----------:|:--------------:|:-------:|\n|               |            | **Input = 0**  | **Input = 1** |\n| \u2192 **s\u2080**      |     **0**      |      s\u2080      |   s\u2081    |\n|   **s\u2081**      |     **1**      |      s\u2080      |   s\u2082    |\n|   **s\u2082**      |     **0**      |      s\u2081      |   s\u2082    |\n\n*(The arrow \u2192 indicates the start state.)*\n\n### Example of Output Generation\n\nAs the problem states, for an input string `a\u2081a\u2082...a\u2096`, the output is `g(s\u2080)g(s\u2081)g(s\u2082)...g(s\u2096)`. Let's trace the input string **101**:\n\n1.  **Start:** The machine starts in state s\u2080. The initial output is `g(s\u2080) = 0`.\n2.  **Input '1':** The machine is in s\u2080 and receives input '1'. According to the table, it transitions to state s\u2081. The output for this step is `g(s\u2081) = 1`.\n3.  **Input '0':** The machine is now in s\u2081 and receives input '0'. It transitions to state s\u2080. The output for this step is `g(s\u2080) = 0`.\n4.  **Input '1':** The machine is now in s\u2080 and receives input '1'. It transitions to state s\u2081. The output for this step is `g(s\u2081) = 1`.\n\nSo, for the input string **101**, the sequence of states is `s\u2080 \u2192 s\u2081 \u2192 s\u2080 \u2192 s\u2081`. The corresponding output string is the concatenation of the outputs from this sequence of states: `g(s\u2080)g(s\u2081)g(s\u2080)g(s\u2081) = **0101**`.",
        "validation_status": "unverified",
        "flags": [],
        "question_type": "short_answer"
    },
    {
        "problem_id": "68-007",
        "source": {
            "type": "extract",
            "name": "Automata Theory"
        },
        "subfield": [
            "Computer Science"
        ],
        "topic": [
            "Finite-State Automata",
            "Automata Equivalence",
            "Automata Minimization"
        ],
        "gradelevel": [],
        "statement": "Answer these questions about the finite-state automaton *M* shown here.\n\na) Find the k-equivalence classes of M for k = 0, 1, 2,\nand 3. Also, find the *-equivalence classes of M.\nb) Construct the quotient automaton M of M.",
        "diagram_data": {
            "type": "latex_tikz",
            "code": "\\begin{tikzpicture}\n    \\node[align=center, text width=0.8\\textwidth] at (0,0) {\n        Cannot generate the specific diagram for the quotient automaton M' \\\n        as the definition of the finite-state automaton M (referred to as 'shown here') \\\n        was not provided in the problem statement.\n        \n        However, this type of problem inherently requires a diagram \\\n        for the original automaton M and its construction (part b) of the quotient automaton M'.\n    };\n\\end{tikzpicture}"
        },
        "hints": [
            "Start by defining 0-equivalence. Two states are 0-equivalent if they are either both accepting states or both non-accepting states. This creates your initial partition.",
            "To find the (k+1)-equivalence classes, refine the k-equivalence classes. Two states in the same k-class are separated if, for some input symbol, they transition to states that belong to different k-classes.",
            "The process of refinement stops when a partition is identical to the previous one (i.e., Pk+1 = Pk). This final partition gives you the *-equivalence classes, which will become the states of the minimized quotient automaton."
        ],
        "solution": "This solution assumes the finite-state automaton *M* has the following properties, as interpreted from the (unseen) diagram. If the diagram is different, the specific classes and transitions will change, but the method remains the same.\n\n**Assumed Automaton M:**\n*   **States (Q):** {q0, q1, q2, q3, q4, q5, q6}\n*   **Alphabet (\u03a3):** {a, b}\n*   **Start State:** q0\n*   **Accepting States (F):** {q2, q5, q6}\n*   **Non-Accepting States (Q-F):** {q0, q1, q3, q4}\n*   **Transition Function (\u03b4):**\n\n| State | Input 'a' | Input 'b' |\n|-------|-----------|-----------|\n| \u2192q0   | q1        | q2        |\n|   q1  | q3        | q4        |\n| *q2   | q5        | q6        |\n|   q3  | q1        | q4        |\n|   q4  | q5        | q6        |\n| *q5   | q5        | q6        |\n| *q6   | q5        | q6        |\n\n--- \n\n### a) k-equivalence and *-equivalence Classes\n\nThe process of finding equivalence classes involves iteratively refining partitions of the states.\n\n**Step 1: Find 0-equivalence classes (P\u2080)**\nTwo states are 0-equivalent if they are both accepting or both non-accepting.\n*   Accepting states (F): {q2, q5, q6}\n*   Non-accepting states (Q-F): {q0, q1, q3, q4}\n\nSo, the 0-equivalence classes are:\n**P\u2080 = {{q0, q1, q3, q4}, {q2, q5, q6}}**\n\n**Step 2: Find 1-equivalence classes (P\u2081)**\nWe refine P\u2080. Two states in a class in P\u2080 are 1-equivalent if, for each input symbol, their transitions lead to states that are in the same class of P\u2080.\n\nLet's analyze the transitions with respect to P\u2080. Let's call C\u2081 = {q0, q1, q3, q4} and C\u2082 = {q2, q5, q6}.\n\n*   **Analysis of {q0, q1, q3, q4}:**\n    *   \u03b4(q0, a) = q1 \u2208 C\u2081 ; \u03b4(q0, b) = q2 \u2208 C\u2082  (Transitions to C\u2081, C\u2082)\n    *   \u03b4(q1, a) = q3 \u2208 C\u2081 ; \u03b4(q1, b) = q4 \u2208 C\u2081  (Transitions to C\u2081, C\u2081)\n    *   \u03b4(q3, a) = q1 \u2208 C\u2081 ; \u03b4(q3, b) = q4 \u2208 C\u2081  (Transitions to C\u2081, C\u2081)\n    *   \u03b4(q4, a) = q5 \u2208 C\u2082 ; \u03b4(q4, b) = q6 \u2208 C\u2082  (Transitions to C\u2082, C\u2082)\n\n    We can see three different transition patterns:\n    1.  q0 transitions to (C\u2081, C\u2082)\n    2.  q1 and q3 transition to (C\u2081, C\u2081)\n    3.  q4 transitions to (C\u2082, C\u2082)\n    Therefore, this class splits into {q0}, {q1, q3}, and {q4}.\n\n*   **Analysis of {q2, q5, q6}:**\n    *   \u03b4(q2, a) = q5 \u2208 C\u2082 ; \u03b4(q2, b) = q6 \u2208 C\u2082 (Transitions to C\u2082, C\u2082)\n    *   \u03b4(q5, a) = q5 \u2208 C\u2082 ; \u03b4(q5, b) = q6 \u2208 C\u2082 (Transitions to C\u2082, C\u2082)\n    *   \u03b4(q6, a) = q5 \u2208 C\u2082 ; \u03b4(q6, b) = q6 \u2208 C\u2082 (Transitions to C\u2082, C\u2082)\n\n    All states in this class have the same transition pattern (C\u2082, C\u2082). So, this class does not split.\n\nCombining the results, the 1-equivalence classes are:\n**P\u2081 = {{q0}, {q1, q3}, {q4}, {q2, q5, q6}}**\n\n**Step 3: Find 2-equivalence classes (P\u2082)**\nWe refine P\u2081. We only need to check classes with more than one state: {q1, q3} and {q2, q5, q6}. Let's name the new classes: C'\u2080={q0}, C'\u2081={q1, q3}, C'\u2082={q4}, C'\u2083={q2, q5, q6}.\n\n*   **Analysis of {q1, q3}:**\n    *   \u03b4(q1, a) = q3 \u2208 C'\u2081 ; \u03b4(q1, b) = q4 \u2208 C'\u2082 (Transitions to C'\u2081, C'\u2082)\n    *   \u03b4(q3, a) = q1 \u2208 C'\u2081 ; \u03b4(q3, b) = q4 \u2208 C'\u2082 (Transitions to C'\u2081, C'\u2082)\n\n    Both q1 and q3 have the same transition pattern with respect to P\u2081. This class does not split.\n\n*   **Analysis of {q2, q5, q6}:**\n    *   \u03b4(q2, a) = q5 \u2208 C'\u2083 ; \u03b4(q2, b) = q6 \u2208 C'\u2083 (Transitions to C'\u2083, C'\u2083)\n    *   \u03b4(q5, a) = q5 \u2208 C'\u2083 ; \u03b4(q5, b) = q6 \u2208 C'\u2083 (Transitions to C'\u2083, C'\u2083)\n    *   \u03b4(q6, a) = q5 \u2208 C'\u2083 ; \u03b4(q6, b) = q6 \u2208 C'\u2083 (Transitions to C'\u2083, C'\u2083)\n\n    All states in this class have the same transition pattern with respect to P\u2081. This class does not split.\n\nSince no classes were split, P\u2082 is the same as P\u2081.\n**P\u2082 = {{q0}, {q1, q3}, {q4}, {q2, q5, q6}}**\n\n**Step 4: Find 3-equivalence classes (P\u2083) and *-equivalence classes**\nSince P\u2082 = P\u2081, the refinement process has stabilized. No further partitions can be made. Therefore, for all k > 1, Pk = P\u2081.\n\n**P\u2083 = P\u2082 = {{q0}, {q1, q3}, {q4}, {q2, q5, q6}}**\n\nThe ***-equivalence classes** are the final, stable partition:\n**P* = {{q0}, {q1, q3}, {q4}, {q2, q5, q6}}**\n\n--- \n\n### b) Construct the Quotient Automaton M\u0304\n\nThe quotient automaton M\u0304 (also written M/\u2261) is the minimized automaton where each state corresponds to one of the *-equivalence classes.\n\nLet's name the *-equivalence classes:\n*   S\u2080 = {q0}\n*   S\u2081 = {q1, q3}\n*   S\u2082 = {q4}\n*   S\u2083 = {q2, q5, q6}\n\nNow we define the components of M\u0304:\n\n*   **States (Q\u0304):** {S\u2080, S\u2081, S\u2082, S\u2083}\n\n*   **Start State:** The class containing the original start state q0. This is **S\u2080**.\n\n*   **Accepting States (F\u0304):** Any class consisting of original accepting states. The original accepting states are {q2, q5, q6}, which make up the class **S\u2083**.\n\n*   **Transition Function (\u03b4\u0304):** We find the transitions by picking any state from a class and seeing which class its transition leads to.\n    *   **\u03b4\u0304(S\u2080, a):** Pick q0 \u2208 S\u2080. \u03b4(q0, a) = q1. Since q1 \u2208 S\u2081, then **\u03b4\u0304(S\u2080, a) = S\u2081**.\n    *   **\u03b4\u0304(S\u2080, b):** Pick q0 \u2208 S\u2080. \u03b4(q0, b) = q2. Since q2 \u2208 S\u2083, then **\u03b4\u0304(S\u2080, b) = S\u2083**.\n    *   **\u03b4\u0304(S\u2081, a):** Pick q1 \u2208 S\u2081. \u03b4(q1, a) = q3. Since q3 \u2208 S\u2081, then **\u03b4\u0304(S\u2081, a) = S\u2081**.\n    *   **\u03b4\u0304(S\u2081, b):** Pick q1 \u2208 S\u2081. \u03b4(q1, b) = q4. Since q4 \u2208 S\u2082, then **\u03b4\u0304(S\u2081, b) = S\u2082**.\n    *   **\u03b4\u0304(S\u2082, a):** Pick q4 \u2208 S\u2082. \u03b4(q4, a) = q5. Since q5 \u2208 S\u2083, then **\u03b4\u0304(S\u2082, a) = S\u2083**.\n    *   **\u03b4\u0304(S\u2082, b):** Pick q4 \u2208 S\u2082. \u03b4(q4, b) = q6. Since q6 \u2208 S\u2083, then **\u03b4\u0304(S\u2082, b) = S\u2083**.\n    *   **\u03b4\u0304(S\u2083, a):** Pick q2 \u2208 S\u2083. \u03b4(q2, a) = q5. Since q5 \u2208 S\u2083, then **\u03b4\u0304(S\u2083, a) = S\u2083**.\n    *   **\u03b4\u0304(S\u2083, b):** Pick q2 \u2208 S\u2083. \u03b4(q2, b) = q6. Since q6 \u2208 S\u2083, then **\u03b4\u0304(S\u2083, b) = S\u2083**.\n\n**Summary of Quotient Automaton M\u0304:**\n*   **States:** {S\u2080, S\u2081, S\u2082, S\u2083}\n*   **Alphabet:** {a, b}\n*   **Start State:** S\u2080\n*   **Accepting States:** {S\u2083}\n*   **Transition Table:**\n\n| State | Input 'a' | Input 'b' |\n|-------|-----------|-----------|\n| \u2192S\u2080   | S\u2081        | S\u2083        |\n|   S\u2081  | S\u2081        | S\u2082        |\n|   S\u2082  | S\u2083        | S\u2083        |\n| *S\u2083   | S\u2083        | S\u2083        |\n",
        "validation_status": "unverified",
        "flags": [],
        "question_type": "short_answer"
    },
    {
        "problem_id": "94-007",
        "source": {
            "type": "extract",
            "name": "Digital Logic Design Textbook"
        },
        "subfield": [
            "Computer Science"
        ],
        "topic": [
            "Karnaugh Maps",
            "Boolean Algebra",
            "Logic Minimization",
            "Hypercube Topology"
        ],
        "gradelevel": [],
        "statement": "*28. Draw a K-map for the 16 minterms in four Boolean vari-ables on the surface of a torus.",
        "diagram_data": {
            "type": "latex_tikz",
            "code": "\\begin{tikzpicture}\n    \\def\\cellsize{1.2cm} % Size of each cell\n\n    % Draw the 4x4 grid for the K-map using a matrix of nodes\n    % Minterm values are ordered according to standard 4-variable K-map conventions\n    % Rows: CD, Columns: AB (Gray code: 00, 01, 11, 10)\n    \\matrix (kmap) [\n        matrix of nodes,\n        nodes={\n            draw, % Draw border for each node (cell)\n            minimum size=\\cellsize, % Make cells square\n            inner sep=0pt, % Remove inner padding\n            font=\\small % Make numbers slightly smaller for better fit\n        },\n        row sep=-\\pgflinewidth, % No extra space between rows\n        column sep=-\\pgflinewidth % No extra space between columns\n    ] {\n        0 & 4 & 12 & 8 \\\\\n        1 & 5 & 13 & 9 \\\\\n        3 & 7 & 15 & 11 \\\\\n        2 & 6 & 14 & 10 \\\\\n    };\n\n    % Draw a diagonal line in the top-left region to separate variable labels\n    \\draw (kmap.north west) -- ($(kmap.north west) + (-0.5*\\cellsize, 0.5*\\cellsize)$);\n\n    % Place variable labels (CD for rows, AB for columns) in the top-left corner region\n    \\node[anchor=south west, font=\\small] at ($(kmap.north west) + (-0.4*\\cellsize, 0.1*\\cellsize)$) {$CD$};\n    \\node[anchor=north east, font=\\small] at ($(kmap.north west) + (0.1*\\cellsize, 0.4*\\cellsize)$) {$AB$};\n\n    % Column labels (AB values in Gray code: 00, 01, 11, 10)\n    \\node[above=0mm of kmap-1-1.north, anchor=south, xshift=\\cellsize/2, font=\\small] {$00$};\n    \\node[above=0mm of kmap-1-2.north, anchor=south, xshift=\\cellsize/2, font=\\small] {$01$};\n    \\node[above=0mm of kmap-1-3.north, anchor=south, xshift=\\cellsize/2, font=\\small] {$11$};\n    \\node[above=0mm of kmap-1-4.north, anchor=south, xshift=\\cellsize/2, font=\\small] {$10$};\n\n    % Row labels (CD values in Gray code: 00, 01, 11, 10)\n    \\node[left=0mm of kmap-1-1.west, anchor=east, yshift=-\\cellsize/2, font=\\small] {$00$};\n    \\node[left=0mm of kmap-2-1.west, anchor=east, yshift=-\\cellsize/2, font=\\small] {$01$};\n    \\node[left=0mm of kmap-3-1.west, anchor=east, yshift=-\\cellsize/2, font=\\small] {$11$};\n    \\node[left=0mm of kmap-4-1.west, anchor=east, yshift=-\\cellsize/2, font=\\small] {$10$};\n\n\\end{tikzpicture}"
        },
        "hints": [
            "Consider the 'wrap-around' adjacency of a standard 4x4 K-map. How is the top row related to the bottom row, and the leftmost column to the rightmost column?",
            "Imagine the flat 4x4 K-map is printed on a flexible sheet of paper. What three-dimensional shape would you get if you first glued the top and bottom edges together?",
            "After forming the shape from the previous hint, what final shape is created when you connect the two remaining open ends?"
        ],
        "solution": "A Karnaugh map (K-map) is a graphical tool used to simplify Boolean expressions. The key principle behind a K-map is its representation of adjacency: minterms whose binary representations differ by only one bit are placed in physically adjacent squares. For a 4-variable K-map, this adjacency extends to the edges in a 'wrap-around' fashion, which can be perfectly represented on the surface of a torus.\n\n**Step 1: The Standard 4-Variable K-map**\n\nA 4-variable Boolean function has 2^4 = 16 minterms. These are typically arranged in a 4x4 grid. Let the variables be A, B, C, and D. We can label the rows with the values of AB and the columns with the values of CD. To maintain adjacency, we use Gray code for the labeling (00, 01, 11, 10).\n\nA standard layout looks like this, with each cell representing a minterm (e.g., m0 = A'B'C'D'):\n\n```\n      CD\n    | 00  | 01  | 11  | 10  |\n----|-----|-----|-----|-----|\nAB 00 | m0  | m1  | m3  | m2  |\n----|-----|-----|-----|-----|\n   01 | m4  | m5  | m7  | m6  |\n----|-----|-----|-----|-----|\n   11 | m12 | m13 | m15 | m14 |\n----|-----|-----|-----|-----|\n   10 | m8  | m9  | m11 | m10 |\n----|-----|-----|-----|-----|\n```\n\n**Step 2: Understanding K-map Adjacency**\n\nThe crucial feature is that adjacent cells differ by only one variable. For example, m0 (0000) is adjacent to m1 (0001) and m4 (0100). The Gray code ordering creates wrap-around adjacencies:\n\n1.  **Vertical Wrap-Around:** The top row (AB=00) is adjacent to the bottom row (AB=10). For instance, m0 (0000) is adjacent to m8 (1000), as they differ only in variable A.\n2.  **Horizontal Wrap-Around:** The leftmost column (CD=00) is adjacent to the rightmost column (CD=10). For example, m0 (0000) is adjacent to m2 (0010), as they differ only in variable C.\n\n**Step 3: Transforming the Flat Map into a Torus**\n\nTo visualize how these adjacencies create a torus, imagine the 4x4 grid is a flexible sheet.\n\n1.  **Create a Cylinder:** Take the sheet and connect the top edge to the bottom edge. This directly represents the vertical wrap-around adjacency. The rows now form continuous bands around the cylinder. The top row (m0, m1, m3, m2) is now physically next to the bottom row (m8, m9, m11, m10).\n\n2.  **Create a Torus:** Now, take this cylinder. Its two ends are open circles, which correspond to the original left and right edges of the map. Bend the cylinder and connect these two circular ends. This represents the horizontal wrap-around adjacency. The leftmost column (m0, m4, m12, m8) is now physically next to the rightmost column (m2, m6, m14, m10).\n\n**Step 4: Drawing the K-map on a Torus**\n\nDrawing this is a conceptual exercise. Imagine a donut shape (a torus). You can draw a 4x4 grid on its surface. \n\n*   The rows of the grid would be four parallel circles that go around the torus the 'long way' (like slicing a bagel).\n*   The columns of the grid would be four parallel circles that go around the torus the 'short way' (like slicing a donut to fill it).\n\nWhen drawn this way, the 16 minterm squares tile the entire surface of the torus. On this surface, every single square has exactly four neighbors (up, down, left, right), with no 'edges' or 'corners'. For example, the square for minterm `m0` would be clearly adjacent to `m1`, `m4`, `m8`, and `m2`. This topological representation perfectly models the complete set of adjacencies required for a 4-variable K-map.",
        "validation_status": "unverified",
        "flags": [],
        "question_type": "short_answer"
    }

]