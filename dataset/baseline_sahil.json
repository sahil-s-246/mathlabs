[
    {
        "problem_id": "62-001",
        "question_type": "short_answer",
        "source": {
            "type": "extract",
            "book_title": "Probability and Statistics for Data Science",
            "authors": [
                "Carlos Fernandez-Granda"
            ],
            "edition": null,
            "chapter": 11,
            "page": "11",
            "exercise_number": "551"
        },
        "subfield": [
            "statistics"
        ],
        "topic": [
            "probability",
            "variance",
            "covariance",
            "decision_theory"
        ],
        "gradelevel": [
            "College-level"
        ],
        "statement": "11.2 (Basketball team) The coach of a basketball team needs to select two out of three players to complete the line-up for the last quarter of a game. The covariance matrix of the points scored by the players per quarter is the following:\n\n<table id=\"0-1\">\n<tr><td></td><td>Player A</td><td>Player B</td><td>Player C</td></tr>\n<tr><td>Player A</td><td>100</td><td>-80</td><td>10</td></tr>\n<tr><td>Player B</td><td>-80</td><td>81</td><td>50</td></tr>\n<tr><td>Player C</td><td>10</td><td>50</td><td>100</td></tr>\n</table>\n\nCompute the variance of the total number of points, if the coach plays the three possible combinations of two players. Assuming all three players score the same number of points on average, which combination would you recommend to the coach, if they are winning by a wide margin? Which would you recommend, if they are losing by a wide margin?",
        "diagram_data": {
            "type": "table",
            "description": "A covariance matrix for the points scored by three basketball players (A, B, C).",
            "image_path": "images/62-001.png"
        },
        "hints": [
            "Recall the formula for the variance of the sum of two random variables, X and Y: $Var(X + Y) = Var(X) + Var(Y) + 2 Cov(X, Y)$.",
            "The diagonal entries of the covariance matrix represent the variance of each player's score. For example, $Var(A) = 100$. The off-diagonal entries represent the covariance between two players.",
            "Think about what variance represents in a real-world scenario. Low variance implies a more predictable and consistent outcome, while high variance implies a less predictable outcome with higher potential for both very good and very bad results.",
            "If the team is winning by a wide margin, the coach likely wants to minimize risk and secure the win. If the team is losing by a wide margin, the coach might need to take a risk on a high-potential but less predictable outcome."
        ],
        "solution": "**1. Compute the variance for each combination:**\nLet A, B, and C be the random variables representing the points scored by each player. The variance of the sum of points for any two players is given by the formula $Var(X + Y) = Var(X) + Var(Y) + 2 Cov(X, Y)$.\n\n* **Combination (A, B):**\n    $Var(A + B) = Var(A) + Var(B) + 2 Cov(A, B)$\n    $Var(A + B) = 100 + 81 + 2(-80) = 181 - 160 = 21$\n\n* **Combination (A, C):**\n    $Var(A + C) = Var(A) + Var(C) + 2 Cov(A, C)$\n    $Var(A + C) = 100 + 100 + 2(10) = 200 + 20 = 220$\n\n* **Combination (B, C):**\n    $Var(B + C) = Var(B) + Var(C) + 2 Cov(B, C)$\n    $Var(B + C) = 81 + 100 + 2(50) = 181 + 100 = 281$\n\n**Summary of Variances:**\n* Pair (A, B): Variance = 21\n* Pair (A, C): Variance = 220\n* Pair (B, C): Variance = 281\n\n**2. Recommendations:**\nSince all players score the same on average, the decision should be based on the variance, which measures the risk or unpredictability of the outcome.\n\n* **Winning by a wide margin:** The coach should choose the most predictable, lowest-risk option to maintain the lead. This corresponds to the pair with the **lowest variance**.\n    * **Recommendation: Players A and B** (Variance = 21). The strong negative covariance means that if one player has an off-quarter, the other tends to compensate, leading to a very consistent total score.\n\n* **Losing by a wide margin:** The coach needs a high-risk, high-reward strategy to have a chance at a comeback. This corresponds to the pair with the **highest variance**, as this combination has the greatest potential for an exceptionally high-scoring quarter (though also the greatest risk of a very low-scoring one).\n    * **Recommendation: Players B and C** (Variance = 281). The large positive covariance means their performances are positively correlated, making a \"boom or bust\" outcome more likely.",
        "validation_status": "verified",
        "flags": []
    },
    {
        "problem_id": "94-001",
        "source": {
            "type": "extract",
            "book_title": "Discrete Mathematics and Its Applications",
            "authors": [
                "Kenneth Rosen"
            ],
            "edition": null,
            "chapter": null,
            "page": null,
            "exercise_number": null
        },
        "subfield": [
            "Computer Science"
        ],
        "topic": [
            "Logic Gates",
            "Boolean Algebra",
            "Digital Circuits"
        ],
        "gradelevel": [],
        "statement": "In Exercises 1\u20134 find the output of the given circuit.\n\n1. Logic circuit with inputs x and y going into an OR gate. Input y also goes into a NOT gate. The outputs of the OR gate and the NOT gate then go into an AND gate, which produces the final output.",
        "diagram_data": {
            "type": "latex_tikz",
            "code": "\\begin{tikzpicture}[circuit logic US,\n    font=\\small,\n    % Gate styles\n    or gate/.append style={draw, fill=white},\n    not gate/.append style={draw, fill=white},\n    and gate/.append style={draw, fill=white},\n    % Wire style\n    line width=0.8pt,\n    % Input/Output connections style\n    logic external connectors, % This enables .input and .output anchors\n    every node/.style={minimum size=0.5cm} % Adjust size for better fit\n]\n    % Gates\n    \\node[or gate] (OR1) at (2, 0.5) {};\n    \\node[not gate] (NOT1) at (2, -1.5) {};\n    \\node[and gate] (AND1) at (4, -0.5) {};\n\n    % Inputs\n    \\coordinate (x_start) at (0, 1.5);\n    \\coordinate (y_start) at (0, -0.5);\n\n    \\node[left=0.1cm of x_start] {x};\n    \\node[left=0.1cm of y_start] {y};\n\n    % Connect x to OR gate\n    \\draw (x_start) -- (OR1.input 1);\n\n    % Connect y to OR gate and NOT gate\n    % Use a branch point for the 'y' input\n    \\draw (y_start) -- ([xshift=0.5cm]y_start) node[coordinate, midway] (y_branch) {} -- (OR1.input 2);\n    \\draw (y_branch) |- (NOT1.input);\n\n    % Connect OR gate output to AND gate\n    \\draw (OR1.output) -- (AND1.input 1);\n\n    % Connect NOT gate output to AND gate\n    \\draw (NOT1.output) -- (AND1.input 2);\n\n    % Final Output\n    \\draw (AND1.output) -- node[above] {Output} ++(1.5, 0);\n\\end{tikzpicture}"
        },
        "hints": [
            "Start by identifying each logic gate in the circuit. Write down the Boolean expression for the output of each of the first-level gates (the OR and NOT gates) in terms of the inputs `x` and `y`.",
            "Trace the outputs from the first-level gates. These outputs become the inputs for the final AND gate.",
            "Combine the expressions you found in the first step. Use the AND operator to connect the output of the OR gate with the output of the NOT gate to get the final expression."
        ],
        "solution": "To find the output of the given logic circuit, we will analyze it step-by-step, determining the output of each gate in the order of signal flow.\n\n**Step 1: Analyze the first-level gates**\n\nThe circuit has two gates that take the initial inputs `x` and `y`:\n1.  **OR Gate:** This gate takes both `x` and `y` as inputs. The Boolean expression for an OR operation is represented by the symbol `\u2228`. Let's call the output of this gate `A`.\n    *   `A = x \u2228 y` (which means `x` OR `y`)\n\n2.  **NOT Gate:** This gate takes only `y` as an input. The Boolean expression for a NOT operation is the negation of its input, represented by the symbol `\u00ac`. Let's call the output of this gate `B`.\n    *   `B = \u00acy` (which means `NOT y`, often written as `y'`)\n\n**Step 2: Analyze the final gate**\n\nThe outputs from the first-level gates, `A` and `B`, are then fed into a final AND gate. This AND gate produces the final output of the entire circuit. Let's call the final output `F`. The Boolean expression for an AND operation is represented by the symbol `\u2227`.\n*   `F = A \u2227 B` (which means `A` AND `B`)\n\n**Step 3: Combine the expressions to find the final output**\n\nNow, we substitute the expressions for `A` and `B` from Step 1 into the expression for `F` from Step 2.\n*   Substitute `A = x \u2228 y` and `B = \u00acy`.\n*   `F = (x \u2228 y) \u2227 (\u00acy)`\n\nThis is the final output expression for the circuit.\n\n**Step 4 (Optional): Simplification and Truth Table Verification**\n\nWe can simplify this expression using the laws of Boolean algebra.\nUsing the distributive law, which states `(P \u2228 Q) \u2227 R = (P \u2227 R) \u2228 (Q \u2227 R)`:\n*   `F = (x \u2227 \u00acy) \u2228 (y \u2227 \u00acy)`\n\nWe know that `y \u2227 \u00acy` (`y` AND `NOT y`) is always false (0), because a variable and its negation can never both be true at the same time. This is the law of non-contradiction.\n*   `F = (x \u2227 \u00acy) \u2228 0`\n\nAccording to the identity law, anything OR'd with 0 is just itself (`P \u2228 0 = P`).\n*   `F = x \u2227 \u00acy`\n\nSo, the simplified output of the circuit is `x \u2227 \u00acy`.\n\nTo verify this, let's create a truth table for the original expression `(x \u2228 y) \u2227 (\u00acy)`:\n\n| x | y | x \u2228 y | \u00acy | (x \u2228 y) \u2227 (\u00acy) |\n|:-:|:-:|:-----:|:--:|:----------------:| \n| 0 | 0 |   0   |  1 |     0 \u2227 1 = **0**    |\n| 0 | 1 |   1   |  0 |     1 \u2227 0 = **0**    |\n| 1 | 0 |   1   |  1 |     1 \u2227 1 = **1**    |\n| 1 | 1 |   1   |  0 |     1 \u2227 0 = **0**    |\n\nThe output is 1 only when `x = 1` and `y = 0`, which is exactly the behavior of the simplified expression `x \u2227 \u00acy`.\n\nTherefore, the output of the given circuit is **(x \u2228 y) \u2227 (\u00acy)**, which simplifies to **x \u2227 \u00acy**.",
        "validation_status": "unverified",
        "flags": [],
        "question_type": "short_answer"
    },
    {
        "problem_id": "94-002",
        "source": {
            "type": "extract",
            "book_title": "Discrete Mathematics and Its Applications",
            "authors": [
                "Kenneth Rosen"
            ],
            "edition": null,
            "chapter": null,
            "page": null,
            "exercise_number": null
        },
        "subfield": [
            "Computer Science"
        ],
        "topic": [
            "Threshold Logic",
            "Boolean Algebra",
            "Digital Logic Gates"
        ],
        "gradelevel": [],
        "statement": "A threshold gate produces an output y of 1 if and only if $w_1x_1 + w_2x_2 + \\dots + w_nx_n \\ge T$. Find a Boolean expression for the Boolean function represented by the threshold gate with inputs $x_1, x_2, x_3$, weights $w_1 = -1, w_2 = 1, w_3 = 2$, and threshold $T = 1/2$.",
        "diagram_data": {
            "type": "none",
            "code": ""
        },
        "hints": [
            "Since the inputs x\u2081, x\u2082, and x\u2083 are Boolean, they can only be 0 or 1. Start by creating a truth table that lists all 8 possible combinations of these inputs.",
            "For each input combination in your truth table, calculate the weighted sum S = (-1)x\u2081 + (1)x\u2082 + (2)x\u2083. Then, determine the output 'y' by checking if S is greater than or equal to the threshold T = 1/2.",
            "Once you have a complete truth table, write down the sum-of-products (disjunctive normal form) expression by OR-ing the minterms for every row where the output is 1. Then, simplify this expression using Boolean algebra or a Karnaugh map."
        ],
        "solution": "The problem asks for a Boolean expression that represents a specific threshold gate. A threshold gate's output, y, is 1 if the weighted sum of its inputs is greater than or equal to a threshold, T. Otherwise, the output is 0.\n\n**Given Parameters:**\n- Inputs: x\u2081, x\u2082, x\u2083\n- Weights: w\u2081 = -1, w\u2082 = 1, w\u2083 = 2\n- Threshold: T = 1/2\n\nThe condition for the output y to be 1 is:\n$w_1x_1 + w_2x_2 + w_3x_3 \\ge T$\n$(-1)x_1 + (1)x_2 + (2)x_3 \\ge 1/2$\n\nTo find the Boolean expression, we can systematically evaluate this condition for all possible combinations of the Boolean inputs x\u2081, x\u2082, and x\u2083.\n\n**Step 1: Create a Truth Table**\nWe will construct a truth table with all 8 possible input combinations (2\u00b3 = 8). For each combination, we'll calculate the weighted sum (let's call it S) and then determine the output y based on whether S \u2265 1/2.\n\n| x\u2081 | x\u2082 | x\u2083 | Weighted Sum (S = -x\u2081 + x\u2082 + 2x\u2083) | Condition (S \u2265 1/2?) | Output (y) |\n|----|----|----|---------------------------------------|--------------------------|------------|\n| 0  | 0  | 0  | -0 + 0 + 2(0) = 0                     | No                       | 0          |\n| 0  | 0  | 1  | -0 + 0 + 2(1) = 2                     | Yes                      | 1          |\n| 0  | 1  | 0  | -0 + 1 + 2(0) = 1                     | Yes                      | 1          |\n| 0  | 1  | 1  | -0 + 1 + 2(1) = 3                     | Yes                      | 1          |\n| 1  | 0  | 0  | -1 + 0 + 2(0) = -1                    | No                       | 0          |\n| 1  | 0  | 1  | -1 + 0 + 2(1) = 1                     | Yes                      | 1          |\n| 1  | 1  | 0  | -1 + 1 + 2(0) = 0                     | No                       | 0          |\n| 1  | 1  | 1  | -1 + 1 + 2(1) = 2                     | Yes                      | 1          |\n\n**Step 2: Derive the Boolean Expression from the Truth Table**\nNow, we identify the input combinations for which the output y is 1. We can write a sum-of-products (disjunctive normal form) expression by creating a minterm for each of these rows and OR-ing them together. A minterm is an AND product of the input variables, where the variable is complemented if its value is 0.\n\nThe rows where y = 1 are:\n- (x\u2081, x\u2082, x\u2083) = (0, 0, 1) \u2192 Minterm: x\u2081'x\u2082'x\u2083\n- (x\u2081, x\u2082, x\u2083) = (0, 1, 0) \u2192 Minterm: x\u2081'x\u2082x\u2083'\n- (x\u2081, x\u2082, x\u2083) = (0, 1, 1) \u2192 Minterm: x\u2081'x\u2082x\u2083\n- (x\u2081, x\u2082, x\u2083) = (1, 0, 1) \u2192 Minterm: x\u2081x\u2082'x\u2083\n- (x\u2081, x\u2082, x\u2083) = (1, 1, 1) \u2192 Minterm: x\u2081x\u2082x\u2083\n\nThe unsimplified Boolean expression is:\ny = x\u2081'x\u2082'x\u2083 + x\u2081'x\u2082x\u2083' + x\u2081'x\u2082x\u2083 + x\u2081x\u2082'x\u2083 + x\u2081x\u2082x\u2083\n\n**Step 3: Simplify the Boolean Expression**\nWe can simplify this expression using Boolean algebra or a Karnaugh map (K-map). Using a K-map is often more straightforward.\n\nHere is the 3-variable K-map for our function y:\n\n      x\u2082x\u2083\nx\u2081   00  01  11  10\n   \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n0  \u2502 0 \u2502 1 \u2502 1 \u2502 1 \u2502\n   \u251c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n1  \u2502 0 \u2502 1 \u2502 1 \u2502 0 \u2502\n   \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n\nWe group the 1s to find the simplest terms:\n1.  **Group 1 (Green):** A 2x2 group covering the cells where x\u2083=1. In this group, x\u2081 and x\u2082 both change, but x\u2083 remains 1. This group simplifies to the term **x\u2083**.\n    (This covers minterms x\u2081'x\u2082'x\u2083, x\u2081'x\u2082x\u2083, x\u2081x\u2082'x\u2083, and x\u2081x\u2082x\u2083.)\n\n          x\u2082x\u2083\n    x\u2081   00  01  11  10\n       \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n    0  \u2502 0 \u2502 1 \u2502 1 \u2502 1 \u2502\n       \u251c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n    1  \u2502 0 \u2502 1 \u2502 1 \u2502 0 \u2502\n       \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n           \\___/ \\___/\n             x\u2083\n\n2.  **Group 2 (Blue):** A horizontal group of two covering the cells where x\u2081=0 and x\u2082=1. In this group, x\u2081 is 0 (x\u2081') and x\u2082 is 1 (x\u2082), while x\u2083 changes. This group simplifies to the term **x\u2081'x\u2082**.\n    (This covers minterms x\u2081'x\u2082x\u2083' and x\u2081'x\u2082x\u2083.)\n\n          x\u2082x\u2083\n    x\u2081   00  01  11  10\n       \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n    0  \u2502 0 \u2502 1 \u2502 1 \u2502 1 \u2502\n       \u251c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2524\u2500\u2500\u2500\u2524   <- x\u2081'x\u2082\n    1  \u2502 0 \u2502 1 \u2502 1 \u2502 0 \u2502\n       \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n\nCombining the terms from our groups gives the final simplified Boolean expression:\ny = x\u2083 + x\u2081'x\u2082\n\n**Final Answer:**\nThe Boolean expression for the given threshold gate is **y = x\u2081'x\u2082 + x\u2083** (or equivalently, **y = x\u2083 OR (NOT x\u2081 AND x\u2082)**).",
        "validation_status": "unverified",
        "flags": [],
        "question_type": "short_answer"
    },


    {
        "problem_id": "94-003",
        "source": {
            "type": "extract",
            "book_title": "Discrete Mathematics and Its Applications",
            "authors": [
                "Kenneth Rosen"
            ],
            "edition": null,
            "chapter": null,
            "page": null,
            "exercise_number": null
        },
        "subfield": [
            "Digital Logic"
        ],
        "topic": [
            "Binary Multiplication",
            "Combinational Logic Design",
            "Logic Gates"
        ],
        "gradelevel": [],
        "statement": "Construct a circuit that computes the product of the two-bit integers (x_1x_0)_2 and (y_1y_0)_2. The circuit should have four output bits for the bits in the product.",
        "diagram_data": {
            "type": "latex_tikz",
            "code": "\\begin{tikzpicture}[\n    % Set styles for gates, inputs, and outputs\n    gate/.style={draw,logic gate,minimum width=0.8cm,minimum height=0.8cm, rounded corners=2pt},\n    input_node/.style={coordinate},\n    output_node/.style={coordinate},\n    every path/.style={thick} % Thicker lines for visibility\n]\n    % Input wires on the left\n    \\node[input_node] (x0_coord) at (0,4.5) {}; \\node[left of=x0_coord, anchor=east] {x0};\n    \\node[input_node] (x1_coord) at (0,3.5) {}; \\node[left of=x1_coord, anchor=east] {x1};\n    \\node[input_node] (y0_coord) at (0,2.5) {}; \\node[left of=y0_coord, anchor=east] {y0};\n    \\node[input_node] (y1_coord) at (0,1.5) {}; \\node[left of=y1_coord, anchor=east] {y1};\n\n    % --- First Stage: Partial Products (AND gates) ---\n    % x0 * y0 -> P0\n    \\node[and gate,gate,anchor=west] (and_x0y0) at (2.5,3.75) {};\n    \\draw (x0_coord) -- ++(0.5,0) |- (and_x0y0.input 1);\n    \\draw (y0_coord) -- ++(0.5,0) |- (and_x0y0.input 2);\n    \\node[output_node] (p0_output) at ([xshift=2cm]and_x0y0.output) {};\n    \\draw (and_x0y0.output) -- (p0_output) node[right] {p0};\n\n    % x1 * y0 (for P1, C1)\n    \\node[and gate,gate,anchor=west] (and_x1y0) at (2.5,2.75) {};\n    \\draw (x1_coord) -- ++(0.5,0) |- (and_x1y0.input 1);\n    \\draw (y0_coord) -- ++(0.5,0) |- (and_x1y0.input 2); % Tap y0\n\n    % x0 * y1 (for P1, C1)\n    \\node[and gate,gate,anchor=west] (and_x0y1) at (2.5,1.75) {};\n    \\draw (x0_coord) -- ++(0.5,0) |- (and_x0y1.input 1); % Tap x0\n    \\draw (y1_coord) -- ++(0.5,0) |- (and_x0y1.input 2);\n\n    % x1 * y1 (for P2, P3)\n    \\node[and gate,gate,anchor=west] (and_x1y1) at (2.5,0.75) {};\n    \\draw (x1_coord) -- ++(0.5,0) |- (and_x1y1.input 1); % Tap x1\n    \\draw (y1_coord) -- ++(0.5,0) |- (and_x1y1.input 2);\n\n    % --- Second Stage: First Half-Adder equivalent (computes P1 and C1) ---\n    % P1 = (x1y0 XOR x0y1)\n    \\node[xor gate,gate,anchor=west] (xor_p1) at (5.5,2.25) {};\n    \\draw (and_x1y0.output) -- ++(0.5,0) |- (xor_p1.input 1);\n    \\draw (and_x0y1.output) -- ++(0.5,0) |- (xor_p1.input 2);\n    \\node[output_node] (p1_output) at ([xshift=2cm]xor_p1.output) {};\n    \\draw (xor_p1.output) -- (p1_output) node[right] {p1};\n\n    % C1 = (x1y0 AND x0y1) (Carry to next stage)\n    \\node[and gate,gate,anchor=west] (and_c1) at (5.5,1.25) {};\n    \\draw (and_x1y0.output) -- ++(0.5,0) |- (and_c1.input 1); % Tap x1y0 output\n    \\draw (and_x0y1.output) -- ++(0.5,0) |- (and_c1.input 2); % Tap x0y1 output\n\n    % --- Third Stage: Second Half-Adder equivalent (computes P2 and P3) ---\n    % P2 = (x1y1 XOR C1)\n    \\node[xor gate,gate,anchor=west] (xor_p2) at (8.5,1.25) {};\n    \\draw (and_x1y1.output) -- ++(0.5,0) |- (xor_p2.input 1);\n    \\draw (and_c1.output) -- ++(0.5,0) |- (xor_p2.input 2);\n    \\node[output_node] (p2_output) at ([xshift=2cm]xor_p2.output) {};\n    \\draw (xor_p2.output) -- (p2_output) node[right] {p2};\n\n    % P3 = (x1y1 AND C1) (Carry from this stage)\n    \\node[and gate,gate,anchor=west] (and_p3) at (8.5,0.25) {};\n    \\draw (and_x1y1.output) -- ++(0.5,0) |- (and_p3.input 1); % Tap x1y1 output\n    \\draw (and_c1.output) -- ++(0.5,0) |- (and_p3.input 2); % Tap C1 output\n    \\node[output_node] (p3_output) at ([xshift=2cm]and_p3.output) {};\n    \\draw (and_p3.output) -- (p3_output) node[right] {p3};\n\n\\end{tikzpicture}"
        },
        "hints": [
            "Think about how you perform multiplication by hand on paper, but in binary. This process involves creating 'partial products' and then adding them together.",
            "The first step is to calculate the four partial products: (x\u2080 * y\u2080), (x\u2081 * y\u2080), (x\u2080 * y\u2081), and (x\u2081 * y\u2081). What single logic gate computes the product of two individual bits?",
            "Once you have the partial products, arrange them according to their place value and add them up. You can use half-adders to perform the binary addition column by column, passing the carry from one column to the next."
        ],
        "solution": "### Introduction\n\nThe goal is to design a combinational logic circuit that multiplies two 2-bit integers, X = (x\u2081x\u2080)\u2082 and Y = (y\u2081y\u2080)\u2082, and produces a 4-bit product, P = (p\u2083p\u2082p\u2081p\u2080)\u2082. The maximum product is 3 * 3 = 9, which requires 4 bits to represent in binary (1001)\u2082.\n\nWe will solve this by simulating the process of long multiplication in binary.\n\n### Step 1: Binary Long Multiplication\n\nFirst, let's write out the multiplication as you would on paper. The multiplication of X by Y is:\n\n```\n      x\u2081  x\u2080\n    * y\u2081  y\u2080\n    --------\n```\n\nMultiplying X by y\u2080 gives the first partial product. Multiplying X by y\u2081 gives the second partial product, which is shifted one position to the left.\n\n```\n              (x\u2081 * y\u2080)  (x\u2080 * y\u2080)   <-- Partial Product 0\n    + (x\u2081 * y\u2081)  (x\u2080 * y\u2081)      0   <-- Partial Product 1 (shifted)\n    ------------------------------\n      p\u2083   p\u2082   p\u2081   p\u2080         <-- Final Product\n```\n\nIn digital logic, the multiplication of two single bits is equivalent to the logical AND operation. Let's define these four partial product terms:\n\n*   `pp\u2080\u2080 = x\u2080 AND y\u2080`\n*   `pp\u2081\u2080 = x\u2081 AND y\u2080`\n*   `pp\u2080\u2081 = x\u2080 AND y\u2081`\n*   `pp\u2081\u2081 = x\u2081 AND y\u2081`\n\nThese four terms can be generated using four 2-input AND gates.\n\n### Step 2: Adding the Partial Products\n\nNow, we need to add the partial products together column by column, just like in manual addition.\n\n```\n          pp\u2081\u2080  pp\u2080\u2080\n    + pp\u2081\u2081  pp\u2080\u2081   0 \n    ------------------\n```\n\nLet's analyze the addition for each output bit of the product `p\u2083p\u2082p\u2081p\u2080`:\n\n**Column for p\u2080 (2\u2070 bit):**\nThe least significant bit of the product, `p\u2080`, is determined solely by the first partial product's LSB.\n*   `p\u2080 = pp\u2080\u2080`\n\n**Column for p\u2081 (2\u00b9 bit):**\nIn this column, we add `pp\u2081\u2080` and `pp\u2080\u2081`. This is a 2-bit addition, which can be performed by a half-adder. A half-adder takes two bits as input and produces a Sum and a Carry output.\n*   The sum bit becomes `p\u2081`.  `p\u2081 = pp\u2081\u2080 XOR pp\u2080\u2081`\n*   The carry-out, let's call it `c\u2081`, goes to the next column. `c\u2081 = pp\u2081\u2080 AND pp\u2080\u2081`\n\n**Column for p\u2082 (2\u00b2 bit):**\nIn this column, we add `pp\u2081\u2081` and the carry from the previous column, `c\u2081`. This can be done with a second half-adder.\n*   The sum bit becomes `p\u2082`. `p\u2082 = pp\u2081\u2081 XOR c\u2081`\n*   The carry-out, `c\u2082`, goes to the final column. `c\u2082 = pp\u2081\u2081 AND c\u2081`\n\n**Column for p\u2083 (2\u00b3 bit):**\nThe most significant bit, `p\u2083`, is simply the carry-out from the `p\u2082` column.\n*   `p\u2083 = c\u2082`\n\n### Step 3: Final Boolean Expressions\n\nNow we can write the complete Boolean expressions for each output bit by substituting the partial product definitions.\n\n1.  **For p\u2080:**\n    `p\u2080 = pp\u2080\u2080`\n    `p\u2080 = x\u2080 * y\u2080`\n\n2.  **For p\u2081:**\n    `p\u2081 = pp\u2081\u2080 XOR pp\u2080\u2081`\n    `p\u2081 = (x\u2081 * y\u2080) XOR (x\u2080 * y\u2081)`\n\n3.  **For p\u2082:**\n    First, let's define the carry `c\u2081`:\n    `c\u2081 = pp\u2081\u2080 * pp\u2080\u2081 = (x\u2081 * y\u2080) * (x\u2080 * y\u2081)`\n    Then, `p\u2082` is:\n    `p\u2082 = pp\u2081\u2081 XOR c\u2081 = (x\u2081 * y\u2081) XOR ((x\u2081 * y\u2080) * (x\u2080 * y\u2081))`\n\n4.  **For p\u2083:**\n    First, let's define the carry `c\u2082`:\n    `c\u2082 = pp\u2081\u2081 * c\u2081 = (x\u2081 * y\u2081) * ((x\u2081 * y\u2080) * (x\u2080 * y\u2081))`\n    The expression for `c\u2082` can be simplified due to the properties of the AND operation (idempotence A*A=A, commutativity, associativity):\n    `c\u2082 = x\u2081 * y\u2081 * x\u2081 * y\u2080 * x\u2080 * y\u2081 = x\u2081 * x\u2080 * y\u2081 * y\u2080`\n    Then, `p\u2083` is:\n    `p\u2083 = c\u2082 = x\u2081 * x\u2080 * y\u2081 * y\u2080`\n\n### Summary of the Circuit Design\n\nThe circuit can be built directly from these final expressions. It requires:\n\n*   **Four 2-input AND gates** to generate the initial partial products: `x\u2080y\u2080`, `x\u2081y\u2080`, `x\u2080y\u2081`, `x\u2081y\u2081`.\n*   **One 2-input XOR gate** to compute `p\u2081` from `x\u2081y\u2080` and `x\u2080y\u2081`.\n*   **A logic block to compute `c\u2081`** (`(x\u2081y\u2080) AND (x\u2080y\u2081)`) which feeds into the logic for `p\u2082` and `p\u2083`.\n*   **A logic block to compute `p\u2082` and `p\u2083`** using the results from the previous steps.\n\nPutting it all together, the final logic is:\n*   `p\u2080 = x\u2080 * y\u2080`\n*   `p\u2081 = (x\u2081 * y\u2080) XOR (x\u2080 * y\u2081)`\n*   `p\u2082 = (x\u2081 * y\u2081) XOR (x\u2081 * x\u2080 * y\u2081 * y\u2080)`\n*   `p\u2083 = x\u2081 * x\u2080 * y\u2081 * y\u2080`\n\nThis design using partial products and adders is a standard method for constructing hardware multipliers.",
        "validation_status": "unverified",
        "flags": [],
        "question_type": "short_answer"
    },
    {
        "problem_id": "68-003",
        "source": {
            "type": "extract",
            "book_title": "Discrete Mathematics and Its Applications",
            "authors": [
                "Kenneth Rosen"
            ],
            "edition": null,
            "chapter": null,
            "page": null,
            "exercise_number": null
        },
        "subfield": [
            "Theory of Computation"
        ],
        "topic": [
            "Deterministic Finite Automata (DFA)",
            "Regular Languages",
            "Formal Languages"
        ],
        "gradelevel": [],
        "statement": "7. Find the set of strings recognized by the deterministic finite-state automaton shown here.",
        "diagram_data": {
            "type": "latex_tikz",
            "code": "\\begin{tikzpicture}[\n    shorten >=1pt,\n    node distance=2.5cm,\n    on grid,\n    auto,\n    state/.style={circle, draw, minimum size=0.8cm}\n  ]\n\n  \\node[state, initial, initial text=Start] (q0) {$q_0$};\n  \\node[state, accepting] (q1) [right of=q0] {$q_1$};\n  \\node[state] (q2) [right of=q1] {$q_2$};\n\n  \\path[->]\n    (q0) edge node {$a$} (q1)\n    (q0) edge [loop above] node {$b$} (q0)\n    (q1) edge node {$b$} (q2)\n    (q1) edge [loop above] node {$a$} (q1)\n    (q2) edge [loop above] node {$a, b$} (q2);\n\n\\end{tikzpicture}"
        },
        "hints": [
            "Identify the start state and the accepting (final) states. A string is recognized if it ends in an accepting state.",
            "Trace the paths for simple strings like '0', '1', '00', '01', and '10'. Pay close attention to what happens when the automaton reads a '1'.",
            "Notice that state s2 is a 'trap state'. Once the automaton enters this state, it can never leave. What does this imply about the strings that lead to this state?"
        ],
        "solution": "To determine the set of strings recognized by this deterministic finite-state automaton (DFA), we need to analyze its components and how they interact.\n\n**1. Identify the DFA Components:**\n*   **States:** There are three states: `s0`, `s1`, and `s2`.\n*   **Alphabet:** The input symbols are `0` and `1`.\n*   **Start State:** `s0` is the start state, indicated by the incoming arrow with no source.\n*   **Accepting States:** `s0` and `s1` are the accepting (or final) states, indicated by the double circles.\n*   **Transitions:** The arrows show the state changes for each input symbol:\n    *   From `s0`: on `0` -> `s1`; on `1` -> `s2`\n    *   From `s1`: on `0` -> `s1`; on `1` -> `s2`\n    *   From `s2`: on `0` -> `s2`; on `1` -> `s2`\n\nA string is accepted if, starting from `s0`, the automaton is in an accepting state (`s0` or `s1`) after reading the entire string.\n\n**2. Analyze Paths to Accepting States:**\n\n*   **Ending in `s0`:** The start state `s0` is an accepting state. This means the **empty string** (a string with no characters) is accepted because the process starts and ends in `s0` without consuming any input.\n    *   Note that once any symbol is read (`0` or `1`), the automaton leaves `s0` and can never return. Therefore, the empty string is the *only* string that ends in state `s0`.\n\n*   **Ending in `s1`:** To reach state `s1`, the first symbol of the string must be `0` (the transition from `s0` to `s1`).\n    *   Once in state `s1`, reading a `0` causes a transition back to `s1`. This means the automaton can read any number of subsequent `0`s and remain in the accepting state `s1`.\n    *   Strings that follow this path are: `0`, `00`, `000`, `0000`, and so on. This set can be described as strings consisting of one or more `0`s.\n\n**3. Analyze Paths to the Non-Accepting State:**\n\n*   **Ending in `s2`:** State `s2` is a non-accepting state. \n    *   The automaton enters state `s2` if it reads a `1` while in either `s0` or `s1`.\n    *   Once in state `s2`, any input (`0` or `1`) will cause a transition back to `s2`. This makes `s2` a **\"trap state\"** or **\"sink state\"**. Once entered, it's impossible to leave.\n    *   This means that any string containing the symbol `1` will eventually lead to state `s2` and be rejected. For example:\n        *   `1`: `s0` -> `s2` (Rejected)\n        *   `01`: `s0` -> `s1` -> `s2` (Rejected)\n        *   `10`: `s0` -> `s2` -> `s2` (Rejected)\n\n**4. Conclusion:**\n\nCombining our observations:\n*   The empty string is accepted.\n*   Strings consisting of one or more `0`s are accepted.\n*   Any string containing a `1` is rejected.\n\nTherefore, the set of strings recognized by this automaton is the set of all strings that do not contain the symbol `1`. This is equivalent to the set of all strings composed entirely of `0`s (including the empty string, which has zero `0`s).\n\nThis language can be formally described using the regular expression `0*` or set notation `{0^n | n \u2265 0}`.",
        "validation_status": "unverified",
        "flags": [],
        "question_type": "short_answer"
    },
    {
        "problem_id": "94-004",
        "source": {
            "type": "extract",
            "book_title": "Discrete Mathematics and Its Applications",
            "authors": [
                "Kenneth Rosen"
            ],
            "edition": null,
            "chapter": null,
            "page": null,
            "exercise_number": null
        },
        "subfield": [
            "Computer Science"
        ],
        "topic": [
            "Logic Gates",
            "NAND and NOR Gates",
            "Universal Gates",
            "Digital Circuits"
        ],
        "gradelevel": [],
        "statement": "<a id='48287af1-c272-4b79-bebe-9ec07378741f'></a>\n\nTwo gates that are often used in circuits are NAND and NOR gates. When NAND or NOR gates are used to represent circuits, no other types of gates are needed. The notation for these gates is as follows:\n<::Two logic gate diagrams are shown side-by-side.\n\nOn the left, a NAND gate is depicted. It has two inputs labeled 'x' and 'y' on the left side. The gate symbol is a D-shape with a small circle (inversion bubble) at its output. The output is labeled 'x NAND y'.\n\nOn the right, a NOR gate is depicted. It also has two inputs labeled 'x' and 'y' on the left side. The gate symbol is a crescent shape (OR gate) with a small circle (inversion bubble) at its output. The output is labeled 'x NOR y'.\n: diagram::>",
        "diagram_data": {
            "type": "latex_tikz",
            "code": "\\begin{tikzpicture}[circuit logic US, thick]\n    % NAND Gate\n    \\node[nand gate, draw, logic external inputs, logic external outputs] at (0,0) (nand_gate) {};\n    \\draw (nand_gate.input 1) -- ++(-0.5,0) node[left] {x};\n    \\draw (nand_gate.input 2) -- ++(-0.5,0) node[left] {y};\n    \\draw (nand_gate.output) -- ++(0.5,0) node[right] {x NAND y};\n\n    % NOR Gate (positioned to the right of the NAND gate)\n    \\node[nor gate, draw, logic external inputs, logic external outputs] at (4,0) (nor_gate) {};\n    \\draw (nor_gate.input 1) -- ++(-0.5,0) node[left] {x};\n    \\draw (nor_gate.input 2) -- ++(-0.5,0) node[left] {y};\n    \\draw (nor_gate.output) -- ++(0.5,0) node[right] {x NOR y};\n\n    % Add labels for the gates explicitly for clarity\n    \\node at (0, -1.5) {NAND Gate};\n    \\node at (4, -1.5) {NOR Gate};\n\\end{tikzpicture}"
        },
        "hints": [
            "Recall the definition of a NAND gate: `x NAND y` is equivalent to `NOT (x AND y)`. To create a single-input NOT gate, consider what happens if you feed the same input signal to both inputs of the NAND gate.",
            "To create an AND gate, think about how to undo the 'N' (the inversion) part of the NAND gate. Since you can build a NOT gate, how can you combine a NAND gate and a NOT gate to get an AND gate?",
            "For the OR gate, De Morgan's laws are key. One of De Morgan's laws states that `x OR y` is equivalent to `NOT ( (NOT x) AND (NOT y) )`. How can you express this structure using only NAND operations?"
        ],
        "solution": "The problem statement introduces NAND and NOR gates as 'universal' or 'functionally complete' gates, meaning they can be used to create any other type of logic gate. This solution will demonstrate this property by constructing the three basic logic gates\u2014NOT, AND, and OR\u2014using only two-input NAND gates.\n\nThe fundamental Boolean expression for a NAND gate with inputs A and B is:\n**A NAND B = NOT(A AND B)**\n\n### Step 1: Constructing a NOT Gate\nA NOT gate (or inverter) has a single input and produces its logical opposite as output. To create a one-input gate from a two-input NAND gate, we can tie the inputs together, feeding the same signal (let's call it A) to both.\n\n*   **Logic:** When both inputs are A, the expression becomes `A NAND A`.\n*   **Applying the NAND definition:** `A NAND A = NOT(A AND A)`.\n*   **Boolean Algebra Rule:** According to the idempotent law of Boolean algebra, `A AND A = A`.\n*   **Result:** Therefore, `A NAND A = NOT(A)`. This configuration successfully functions as a NOT gate.\n*   **Implementation:** 1 NAND gate is required.\n\n### Step 2: Constructing an AND Gate\nAn AND gate performs the `A AND B` operation. We can see from the NAND definition that its output is an inverted AND (`NOT(A AND B)`). To get the AND function, we simply need to invert the output of a NAND gate.\n\n*   **Logic:** We can take the output of one NAND gate and pass it through the NOT gate we constructed in Step 1.\n*   **The first stage:** Calculate `A NAND B`.\n*   **The second stage (inversion):** Feed the result of the first stage into a NOT gate. This is represented as `(A NAND B) NAND (A NAND B)`.\n*   **Applying the logic from Step 1:** We know `X NAND X = NOT(X)`. So, `(A NAND B) NAND (A NAND B) = NOT(A NAND B)`.\n*   **Result:** Substituting the definition of NAND back in, we get `NOT(NOT(A AND B))`. The double negation cancels out, leaving `A AND B`.\n*   **Implementation:** 2 NAND gates are required.\n\n### Step 3: Constructing an OR Gate\nConstructing an OR gate (`A OR B`) from NAND gates is the most complex of the three and relies on De Morgan's laws. One of De Morgan's laws can be written as:\n**A OR B = NOT( (NOT A) AND (NOT B) )**\n\nLet's analyze the right side of this equation:\n*   It describes an AND operation performed on `NOT A` and `NOT B`.\n*   The entire result of that AND operation is then inverted (NOT).\n*   An inverted AND operation is precisely the definition of a NAND gate. So, we can rewrite the equation as:\n    **A OR B = (NOT A) NAND (NOT B)**\n\nThis gives us a clear recipe for building an OR gate:\n1.  Generate `NOT A` using a NAND gate (as shown in Step 1).\n2.  Generate `NOT B` using another NAND gate (as shown in Step 1).\n3.  Feed the outputs of these two gates into a third NAND gate.\n\n*   **The logic is:** `(A NAND A) NAND (B NAND B)`\n*   **Substituting the results from Step 1:** This becomes `(NOT A) NAND (NOT B)`.\n*   **Result:** As shown by De Morgan's law, this expression is equivalent to `A OR B`.\n*   **Implementation:** 3 NAND gates are required.\n\n**Conclusion:**\nWe have successfully constructed NOT, AND, and OR gates using only NAND gates. Since any digital logic circuit can be built from these three basic gates, this proves that the NAND gate is functionally complete, as mentioned in the problem statement. A similar process can be used to prove that the NOR gate is also functionally complete.",
        "validation_status": "unverified",
        "flags": [],
        "question_type": "short_answer"
    },
    {
        "problem_id": "94-005",
        "source": {
            "type": "extract",
            "book_title": "Discrete Mathematics and Its Applications",
            "authors": [
                "Kenneth Rosen"
            ],
            "edition": null,
            "chapter": null,
            "page": null,
            "exercise_number": null
        },
        "subfield": [
            "Computer Science"
        ],
        "topic": [
            "Karnaugh Maps",
            "Boolean Algebra",
            "Logic Minimization"
        ],
        "gradelevel": [],
        "statement": "6. Use K-maps to find simpler circuits with the same output as each of the circuits shown.",
        "diagram_data": {
            "type": "none",
            "code": ""
        },
        "hints": [
            "First, determine the Boolean algebra expression for the output Z based on the logic gates in the circuit diagram.",
            "Convert the Boolean expression into a sum-of-products (SOP) form. Then, create a 3-variable K-map and fill it in by placing a '1' for each minterm present in your SOP expression.",
            "After filling the K-map, identify the largest possible rectangular groups of '1's (groups of 2, 4, or 8). A larger group will result in a more simplified term."
        ],
        "solution": "The process of simplifying a logic circuit using a Karnaugh map (K-map) involves three main steps: deriving the Boolean expression from the circuit, plotting this expression on a K-map, and then grouping the terms to find the simplest possible expression.\n\n### Step 1: Derive the Boolean Expression from the Circuit\n\nFirst, we analyze the circuit to find the Boolean expression for the output Z in terms of the inputs A, B, and C.\n\n1.  The top part of the circuit calculates `(A AND B) AND (NOT C)`. In Boolean notation, this is `A \u22c5 B \u22c5 C'` or simply `ABC'`. \n2.  The bottom part of the circuit calculates `A AND ((NOT B) OR C)`. In Boolean notation, this is `A \u22c5 (B' + C)`. \n3.  The outputs of these two parts are fed into an OR gate. Therefore, the final expression for the output Z is the sum of these two terms:\n    `Z = ABC' + A(B' + C)`\n\n### Step 2: Expand the Expression and Create the K-map\n\nTo use a K-map, it's easiest to work with a sum-of-products (SOP) form. We can expand the expression using the distributive law:\n\n`Z = ABC' + A(B' + C)`\n`Z = ABC' + AB' + AC`\n\nNow we create a 3-variable K-map for inputs A, B, and C. We will place a '1' in the map for each term in the SOP expression.\n\n*   `ABC'` corresponds to the cell where A=1, B=1, C=0.\n*   `AB'` corresponds to the cells where A=1 and B=0. This covers two cells: A=1, B=0, C=0 and A=1, B=0, C=1.\n*   `AC` corresponds to the cells where A=1 and C=1. This covers two cells: A=1, B=0, C=1 and A=1, B=1, C=1.\n\nLet's plot these on the K-map. The cells that get a '1' are (A,B,C):\n(1,1,0), (1,0,0), (1,0,1), (1,1,1).\nThese correspond to minterms 6, 4, 5, and 7 respectively.\n\nThe 3-variable K-map looks like this:\n\n```\n      BC\n      00  01  11  10\n    +---+---+---+---+\n A 0| 0 | 0 | 0 | 0 |\n    +---+---+---+---+\n   1| 1 | 1 | 1 | 1 |\n    +---+---+---+---+\n```\n_Note: The cells are indexed by minterm numbers as follows:_\n_Row 0: 0, 1, 3, 2_ \n_Row 1: 4, 5, 7, 6_ \n\n### Step 3: Group the Minterms and Simplify the Expression\n\nNow, we look for the largest possible groups of adjacent '1's. The group sizes must be powers of two (1, 2, 4, 8, etc.).\n\nIn our K-map, all four '1's in the second row (where A=1) can be combined into a single group of four.\n\n```\n      BC\n      00  01  11  10\n    +---+---+---+---+\n A 0| 0 | 0 | 0 | 0 |\n    +---\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510---+\n   1| \u2502 1 \u2502 1 \u2502 1 \u2502 1 \u2502 |\n    +---\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518---+\n```\n\nLet's analyze this group to find the simplified term:\n\n*   **For variable A:** Throughout the entire group, A is always **1**. So, A is part of the simplified term.\n*   **For variable B:** Within the group, B takes on values of 0 (in columns 00 and 01) and 1 (in columns 11 and 10). Since B changes, it is eliminated.\n*   **For variable C:** Within the group, C takes on values of 0 (in columns 00 and 10) and 1 (in columns 01 and 11). Since C changes, it is also eliminated.\n\nThe only variable that remains constant for the entire group is A. \n\nTherefore, the simplified Boolean expression is:\n`Z = A`\n\n### Conclusion\n\nThe original complex circuit can be replaced by a much simpler circuit with the same output. The output Z is simply equal to the input A. This means the circuit can be simplified to a single wire connecting the input A directly to the output Z.",
        "validation_status": "unverified",
        "flags": [],
        "question_type": "short_answer"
    },
    {
        "problem_id": "68-004",
        "source": {
            "type": "extract",
            "book_title": "Discrete Mathematics and Its Applications",
            "authors": [
                "Kenneth Rosen"
            ],
            "edition": null,
            "chapter": null,
            "page": null,
            "exercise_number": null
        },
        "subfield": [
            "Theoretical Computer Science"
        ],
        "topic": [
            "Finite Automata",
            "Regular Languages",
            "Automaton Construction",
            "Parity Logic"
        ],
        "gradelevel": [],
        "statement": "36. Construct a finite-state automaton with four states that recognizes the set of bit strings containing an even number of 1s and an odd number of 0s.",
        "diagram_data": {
            "type": "latex_tikz",
            "code": "\\begin{tikzpicture}[shorten >=1pt,node distance=2.5cm,on grid,auto]\n    % Define states\n    % q_ee: Even 1s, Even 0s (Initial State)\n    \\node[state, initial] (q_ee) {$S_{ee}$};\n    % q_eo: Even 1s, Odd 0s (Accepting State)\n    \\node[state, accepting] (q_eo) [right=of q_ee] {$S_{eo}$};\n    % q_oe: Odd 1s, Even 0s\n    \\node[state] (q_oe) [below=of q_ee] {$S_{oe}$};\n    % q_oo: Odd 1s, Odd 0s\n    \\node[state] (q_oo) [below=of q_eo] {$S_{oo}$};\n\n    % Define transitions\n    \\path[->]\n    % Transitions for input '0'\n    % '0' flips the parity of 0s count\n    (q_ee) edge[bend left] node {0} (q_eo)\n    (q_eo) edge[bend left] node {0} (q_ee)\n    (q_oe) edge[bend left] node {0} (q_oo)\n    (q_oo) edge[bend left] node {0} (q_oe)\n\n    % Transitions for input '1'\n    % '1' flips the parity of 1s count\n    (q_ee) edge[bend right] node {1} (q_oe)\n    (q_oe) edge[bend right] node {1} (q_ee)\n    (q_eo) edge[bend right] node {1} (q_oo)\n    (q_oo) edge[bend right] node {1} (q_eo);\n\\end{tikzpicture}"
        },
        "hints": [
            "Consider what information the automaton needs to remember about the input string it has processed so far. The problem's conditions relate to the counts of 0s and 1s. What specific property of these counts is important?",
            "The problem requires tracking two independent properties: the parity (even/odd) of the number of 0s and the parity of the number of 1s. How many combined states of parity are there? This should match the required number of states.",
            "The initial state represents the properties of the empty string (which has zero 0s and zero 1s). The accepting state must be the one that perfectly matches the conditions required by the problem statement."
        ],
        "solution": "The goal is to construct a finite-state automaton (FSA) with four states that recognizes bit strings containing an even number of 1s and an odd number of 0s. This means the FSA must keep track of the parity (even or odd) of the counts of both 0s and 1s seen so far.\n\n### Step 1: Defining the States\n\nWe have two properties to track, each with two possible values:\n1.  Parity of the number of 0s: Even or Odd.\n2.  Parity of the number of 1s: Even or Odd.\n\nThis gives us 2 x 2 = 4 possible combinations, which corresponds to the four states required by the problem. Let's define each state based on the parity of the counts of 0s and 1s processed so far:\n\n*   **S\u2080 (or `S_ee`):** Represents the state where an **even** number of 0s and an **even** number of 1s have been read.\n*   **S\u2081 (or `S_eo`):** Represents the state where an **even** number of 0s and an **odd** number of 1s have been read.\n*   **S\u2082 (or `S_oe`):** Represents the state where an **odd** number of 0s and an **even** number of 1s have been read.\n*   **S\u2083 (or `S_oo`):** Represents the state where an **odd** number of 0s and an **odd** number of 1s have been read.\n\n### Step 2: Identifying the Start and Accepting States\n\n*   **Start State:** The automaton starts before reading any input. The empty string \"\" has zero 0s and zero 1s. Since 0 is an even number, the initial state corresponds to having an even number of 0s and an even number of 1s. Therefore, **S\u2080 is the start state**.\n\n*   **Accepting State(s):** The problem asks for the FSA to recognize strings with an **even number of 1s** and an **odd number of 0s**. This directly corresponds to the definition of state S\u2082. Therefore, **S\u2082 is the only accepting state**.\n\n### Step 3: Defining the Transitions\n\nNext, we determine how the automaton transitions between states upon reading a '0' or a '1'.\n\n*   **If the input is '0':** The count of 0s changes its parity (even becomes odd, odd becomes even). The count of 1s remains unchanged, so its parity does not change.\n    *   From S\u2080 (even 0s, even 1s) \u2192 S\u2082 (odd 0s, even 1s)\n    *   From S\u2081 (even 0s, odd 1s) \u2192 S\u2083 (odd 0s, odd 1s)\n    *   From S\u2082 (odd 0s, even 1s) \u2192 S\u2080 (even 0s, even 1s)\n    *   From S\u2083 (odd 0s, odd 1s) \u2192 S\u2081 (even 0s, odd 1s)\n\n*   **If the input is '1':** The count of 1s changes its parity. The count of 0s remains unchanged, so its parity does not change.\n    *   From S\u2080 (even 0s, even 1s) \u2192 S\u2081 (even 0s, odd 1s)\n    *   From S\u2081 (even 0s, odd 1s) \u2192 S\u2080 (even 0s, even 1s)\n    *   From S\u2082 (odd 0s, even 1s) \u2192 S\u2083 (odd 0s, odd 1s)\n    *   From S\u2083 (odd 0s, odd 1s) \u2192 S\u2082 (odd 0s, even 1s)\n\n### Step 4: Summarizing the Automaton\n\nWe can summarize the complete FSA using a transition table and a state diagram.\n\n**Transition Table:**\n\n| Current State | Description           | Input '0' | Input '1' |\n|---------------|-----------------------|-----------|-----------|\n| \u2192 **S\u2080**      | even 0s, even 1s      | S\u2082        | S\u2081        |\n|   **S\u2081**      | even 0s, odd 1s       | S\u2083        | S\u2080        |\n| * **S\u2082**      | odd 0s, even 1s       | S\u2080        | S\u2083        |\n|   **S\u2083**      | odd 0s, odd 1s        | S\u2081        | S\u2082        |\n\n(\u2192 indicates the start state, * indicates an accepting state)\n\n**Formal Definition (5-tuple M = (Q, \u03a3, \u03b4, q\u2080, F)):**\n*   **Q (States):** {S\u2080, S\u2081, S\u2082, S\u2083}\n*   **\u03a3 (Alphabet):** {0, 1}\n*   **q\u2080 (Start State):** S\u2080\n*   **F (Accepting States):** {S\u2082}\n*   **\u03b4 (Transition Function):** As defined by the table above.\n\n**Example Walkthrough:**\nLet's trace the string \"101\":\n1.  Start at S\u2080.\n2.  Read '1': Transition from S\u2080 to S\u2081.\n3.  Read '0': Transition from S\u2081 to S\u2083.\n4.  Read '1': Transition from S\u2083 to S\u2082.\n5.  End of string. The automaton is in state S\u2082. Since S\u2082 is an accepting state, the string \"101\" is accepted. This is correct, as \"101\" has one 0 (odd) and two 1s (even).\n\nLet's trace the string \"00\":\n1.  Start at S\u2080.\n2.  Read '0': Transition from S\u2080 to S\u2082.\n3.  Read '0': Transition from S\u2082 to S\u2080.\n4.  End of string. The automaton is in state S\u2080. Since S\u2080 is not an accepting state, the string \"00\" is rejected. This is correct, as \"00\" has two 0s (even) and zero 1s (even), which does not meet the criteria.",
        "validation_status": "unverified",
        "flags": [],
        "question_type": "short_answer"
    },
    {
        "problem_id": "94-006",
        "source": {
            "type": "extract",
            "book_title": "Discrete Mathematics and Its Applications",
            "authors": [
                "Kenneth Rosen"
            ],
            "edition": null,
            "chapter": null,
            "page": null,
            "exercise_number": null
        },
        "subfield": [
            "Computer Engineering"
        ],
        "topic": [
            "Karnaugh Maps (K-maps)",
            "Boolean Algebra",
            "Logic Minimization",
            "Sum-of-Products (SOP) Form"
        ],
        "gradelevel": [],
        "statement": "2. Find the sum-of-products expansions represented by each\nof these K-maps.\n\na)\n<::Karnaugh map\n: y y\u0304\nx 1 \nx\u0304 1 1\n: chart::>\n\n<::Karnaugh map::>\nA Karnaugh map with two rows and two columns.\n\nColumn labels from left to right are: y, y\u0304.\nRow labels from top to bottom are: x, x\u0304.\n\nCell values:\n- Row x, Column y: 1\n- Row x, Column y\u0304: 1\n- Row x\u0304, Column y: (empty)\n- Row x\u0304, Column y\u0304: (empty)\n<::/Karnaugh map::>\n\n<::c)\n\n|   | y | y\u0304 |\n|---|---|---|\n| x | 1 | 1 |\n| x\u0304 | 1 | 1 |\n: Karnaugh map::>",
        "diagram_data": {
            "type": "latex_tikz",
            "code": "\\begin{tikzpicture}[\n    kmap_cell/.style={rectangle, draw, minimum size=1cm, thick, font=\\bfseries},\n    kmap_header/.style={font=\\sffamily\\bfseries, minimum size=1cm},\n    kmap_header_corner/.style={minimum size=1cm, draw=none}\n]\n\n% K-map (a)\n\\node[kmap_header_corner] at (-1.5, 0.5) {a)};\n\n\\matrix[row sep=-\\pgflinewidth, column sep=-\\pgflinewidth] at (0,0) {\n    \\node[kmap_header] (topleft) {}; & \\node[kmap_header] {$y$}; & \\node[kmap_header] {$\\bar{y}$}; \\\\\n    \\node[kmap_header] {$x$}; & \\node[kmap_cell] {1}; & \\node[kmap_cell] {1}; \\\\\n    \\node[kmap_header] {$\\bar{x}$}; & \\node[kmap_cell] {0}; & \\node[kmap_cell] {0}; \\\\\n};\n% Draw line for variable labels\n\\draw[thick] (topleft.south east) -- ($(topleft.south east)+(0.5,-0.5)$);\n\\node[above right, font=\\sffamily\\bfseries] at (topleft.south east) {$y$};\n\\node[below left, font=\\sffamily\\bfseries] at (topleft.south east) {$x$};\n\n% K-map (c)\n\\node[kmap_header_corner] at (2.5, 0.5) {c)};\n\n\\matrix[row sep=-\\pgflinewidth, column sep=-\\pgflinewidth] at (4,0) {\n    \\node[kmap_header] (topleft2) {}; & \\node[kmap_header] {$y$}; & \\node[kmap_header] {$\\bar{y}$}; \\\\\n    \\node[kmap_header] {$x$}; & \\node[kmap_cell] {1}; & \\node[kmap_cell] {1}; \\\\\n    \\node[kmap_header] {$\\bar{x}$}; & \\node[kmap_cell] {1}; & \\node[kmap_cell] {1}; \\\\\n};\n% Draw line for variable labels\n\\draw[thick] (topleft2.south east) -- ($(topleft2.south east)+(0.5,-0.5)$);\n\\node[above right, font=\\sffamily\\bfseries] at (topleft2.south east) {$y$};\n\\node[below left, font=\\sffamily\\bfseries] at (topleft2.south east) {$x$};\n\n\\end{tikzpicture}"
        },
        "hints": [
            "Identify adjacent '1's in the Karnaugh map. The goal is to encircle them in the largest possible rectangular groups whose dimensions are powers of two (e.g., 1, 2, 4).",
            "For each group you form, find the variable(s) that remain constant across all cells in that group. The product of these constant variables creates a term in your final expression.",
            "Make sure that every '1' on the map is included in at least one group. A single '1' can be part of multiple groups if it helps to create larger groupings."
        ],
        "solution": "To find the sum-of-products (SOP) expansion from a Karnaugh map (K-map), we group adjacent cells containing '1's. Each group represents a product term, and the final expression is the sum of these terms.\n\n### Part a)\n\nThe K-map is given as:\n\n|   | y | y\u0304 |\n|---|---|---|\n| x | 1 |   |\n| x\u0304 | 1 | 1 |\n\n**Step 1: Identify the '1's and potential groups.**\nThere are three '1's in the map. The cells with '1's correspond to the minterms `xy`, `x\u0304y`, and `x\u0304y\u0304`.\n\n**Step 2: Form the largest possible groups to cover all '1's.**\nWe can form two groups to cover all three '1's.\n\n*   **Group 1 (Horizontal):** We can group the two '1's in the `x\u0304` row. This group covers the cells `x\u0304y` and `x\u0304y\u0304`.\n    *   **Analyze the variables for this group:**\n        *   The row variable is `x\u0304`, which is constant for both cells.\n        *   The column variable changes from `y` to `y\u0304`. Since the variable `y` is not constant, it is eliminated.\n    *   The product term for this group is **`x\u0304`**.\n\n*   **Group 2 (Vertical):** We can group the two '1's in the `y` column. This group covers the cells `xy` and `x\u0304y`. Note that the cell `x\u0304y` is part of both groups, which is allowed.\n    *   **Analyze the variables for this group:**\n        *   The row variable changes from `x` to `x\u0304`. Since the variable `x` is not constant, it is eliminated.\n        *   The column variable is `y`, which is constant for both cells.\n    *   The product term for this group is **`y`**.\n\n**Step 3: Combine the terms.**\nAll '1's have been covered by at least one group. The final sum-of-products expansion is the sum of the terms from each group.\n\n**Final Answer for a): `x\u0304 + y`**\n\n--- \n\n### Part c)\n\nThe K-map is given as:\n\n|   | y | y\u0304 |\n|---|---|---|\n| x | 1 | 1 |\n| x\u0304 | 1 | 1 |\n\n**Step 1: Identify the '1's and potential groups.**\nAll four cells in the K-map contain a '1'.\n\n**Step 2: Form the largest possible group.**\nSince all four cells are '1's and are adjacent, we can form a single large 2x2 group that covers the entire map.\n\n*   **Group 1 (The entire map):** This group covers the cells `xy`, `xy\u0304`, `x\u0304y`, and `x\u0304y\u0304`.\n    *   **Analyze the variables for this group:**\n        *   The group spans both row `x` and row `x\u0304`. Since the variable `x` appears in both its uncomplemented (`x`) and complemented (`x\u0304`) forms, it is eliminated.\n        *   The group also spans both column `y` and column `y\u0304`. Since the variable `y` appears in both its uncomplemented (`y`) and complemented (`y\u0304`) forms, it is also eliminated.\n\n**Step 3: Determine the final expression.**\nWhen all variables in a group are eliminated, the resulting term is the Boolean constant **`1`**. Since this single group covers all the '1's, this is our final expression.\n\n**Final Answer for c): `1`**",
        "validation_status": "unverified",
        "flags": [],
        "question_type": "short_answer"
    }

]